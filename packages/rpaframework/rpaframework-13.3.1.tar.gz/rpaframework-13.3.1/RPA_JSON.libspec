<?xml version="1.0" encoding="UTF-8"?>
<keywordspec name="RPA.JSON" type="LIBRARY" format="REST" scope="GLOBAL" generated="2022-04-15T14:31:04Z" specversion="3" source="./RPA/JSON.py" lineno="14">
<version/>
<doc>`JSON` is a library for manipulating `JSON`_ files and strings.

JSON is a common data interchange format inspired by a subset of
the Javascript programming language, but these days is a de facto
standard in modern web APIs and is language agnostic.

.. _JSON: http://json.org/

**Serialization**

The term `serialization` refers to the process of converting
Robot Framework or Python types to JSON or the other way around.

Basic types can be easily converted between the domains,
and the mapping is as follows:

============= =======
JSON          Python
============= =======
object        dict
array         list
string        str
number (int)  int
number (real) float
true          True
false         False
null          None
============= =======

**About JSONPath**

Reading and writing values from/to JSON serializable objects is done
using `JSONPath`_. It's a syntax designed to quickly and easily refer to
specific elements in a JSON structure.

Compared to Python's normal dictionary access, JSONPath expressions can
target multiple elements through features such as conditionals and wildcards,
which can simplify many JSON-related operations. It's analogous to XPath
for XML structures.

.. _JSONPath: http://goessner.net/articles/JsonPath/

**Syntax example**

For this example consider the following structure:

.. code-block:: json

   {
     "clients": [
       {
         "name": "Johnny Example",
         "email": "john@example.com",
         "orders": [
             {"address": "Streetroad 123", "price": 103.20},
             {"address": "Streetroad 123", "price": 98.99}
         ]
       },
       {
         "name": "Jane Example",
         "email": "jane@example.com",
         "orders": [
             {"address": "Waypath 321", "price": 22.00},
             {"address": "Streetroad 123", "price": 2330.01}
         ]
       }
     ]
   }

In the simplest case JSONPath can replace nested access:

.. code-block:: robotframework

   # First order of first client, with direct dictionary access
   ${value}=    Set variable    ${json}["clients"][0]["orders"][0]

   # JSONPath access
   ${value}=    Get value from JSON    ${json}    $.clients[0].orders[0]

But the power comes from complicated expressions:

.. code-block:: robotframework

   # Find delivery addresses for all orders
   ${prices}=        Get values from JSON    $..address

   # Find orders that cost over 100
   ${expensives}=    Get values from JSON    $..orders[?(@.price&gt;100)]


**Supported Expressions**

The supported syntax elements are:

======== ===========
Element  Description
======== ===========
$        Root object/element
@        Current object/element
\. or [] Child operator
\.\.     Recursive descent
\*       Wilcard, any element
[n]      Array index
[a:b:c]  Array slice (start, end, step)
[a,b]    Union of indices or names
?()      Apply a filter expression
()       Script expression
======== ===========

There are a multitude of different script expressions
in addition to the elements listed above, which can
be seen in the `aforementioned article`__.

For further library usage examples, see the individual keywords.

__ JSONPath_</doc>
<tags>
</tags>
<inits>
</inits>
<keywords>
<kw name="Add to JSON" source="./RPA/JSON.py" lineno="237">
<arguments repr="doc: Dict[str, typing.Any] | List[typing.Any] | str | int | float | bool | None, expr: str, value: Dict[str, typing.Any] | List[typing.Any] | str | int | float | bool | None">
<arg kind="POSITIONAL_OR_NAMED" required="true" repr="doc: Dict[str, typing.Any] | List[typing.Any] | str | int | float | bool | None">
<name>doc</name>
<type>Dict[str, typing.Any]</type>
<type>List[typing.Any]</type>
<type>str</type>
<type>int</type>
<type>float</type>
<type>bool</type>
<type>None</type>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="true" repr="expr: str">
<name>expr</name>
<type>str</type>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="true" repr="value: Dict[str, typing.Any] | List[typing.Any] | str | int | float | bool | None">
<name>value</name>
<type>Dict[str, typing.Any]</type>
<type>List[typing.Any]</type>
<type>str</type>
<type>int</type>
<type>float</type>
<type>bool</type>
<type>None</type>
</arg>
</arguments>
<doc>Add items into a JSON serializable object and return the result.

If the target is a list, the values are appended to the end.
If the target is a dict, the keys are either added or updated.

:param doc: JSON serializable object
:param expr: JSONPath expression
:param value: values to either append or update
:return: JSON serializable object of the updated JSON

Example:

.. code:: robotframework

   # Change the name value for all people
   &amp;{before}=    Convert string to JSON   {"People": [{"Name": "Mark"}, {"Name": "Jane"}]}
   &amp;{person}=    Create dictionary      Name=John
   &amp;{after}=     Add to JSON    ${before}   $.People    ${person}</doc>
<shortdoc>Add items into a JSON serializable object and return the result.</shortdoc>
</kw>
<kw name="Convert JSON to String" source="./RPA/JSON.py" lineno="201">
<arguments repr="doc: Dict[str, typing.Any] | List[typing.Any] | str | int | float | bool | None">
<arg kind="POSITIONAL_OR_NAMED" required="true" repr="doc: Dict[str, typing.Any] | List[typing.Any] | str | int | float | bool | None">
<name>doc</name>
<type>Dict[str, typing.Any]</type>
<type>List[typing.Any]</type>
<type>str</type>
<type>int</type>
<type>float</type>
<type>bool</type>
<type>None</type>
</arg>
</arguments>
<doc>Convert a JSON serializable object to a string and return it.

:param doc: JSON serializable object
:return: string of the JSON serializable object

Example:

.. code:: robotframework

   ${obj}=    Create dictionary    Key=Value
   ${json}=   Convert JSON to string    ${obj}
   Should be equal    ${json}     {"Key": "Value"}</doc>
<shortdoc>Convert a JSON serializable object to a string and return it.</shortdoc>
</kw>
<kw name="Convert String to JSON" source="./RPA/JSON.py" lineno="219">
<arguments repr="doc: str">
<arg kind="POSITIONAL_OR_NAMED" required="true" repr="doc: str">
<name>doc</name>
<type>str</type>
</arg>
</arguments>
<doc>Convert a string to a JSON serializable object and return it.

:param doc: JSON string
:return: JSON serializable object of the string

Example:

.. code:: robotframework

   ${json}=    Set variable    {"Key": "Value"}
   &amp;{obj}=     Convert string to JSON    ${json}
   Should be equal    ${obj.Key}    Value</doc>
<shortdoc>Convert a string to a JSON serializable object and return it.</shortdoc>
</kw>
<kw name="Delete from JSON" source="./RPA/JSON.py" lineno="354">
<arguments repr="doc: Dict[str, typing.Any] | List[typing.Any] | str | int | float | bool | None, expr: str">
<arg kind="POSITIONAL_OR_NAMED" required="true" repr="doc: Dict[str, typing.Any] | List[typing.Any] | str | int | float | bool | None">
<name>doc</name>
<type>Dict[str, typing.Any]</type>
<type>List[typing.Any]</type>
<type>str</type>
<type>int</type>
<type>float</type>
<type>bool</type>
<type>None</type>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="true" repr="expr: str">
<name>expr</name>
<type>str</type>
</arg>
</arguments>
<doc>Delete values from a JSON serializable object and return the result.
Will delete all values that match the expression.

:param doc: JSON serializable object or string
:param expr: JSONPath expression
:return: JSON serializable object with values removed

Example:

.. code:: robotframework

   # Delete all people
   &amp;{before}=    Convert string to JSON   {"People": [{"Name": "Mark"}, {"Name": "Jane"}]}
   &amp;{after}=     Delete from JSON    ${before}   $.People[*]</doc>
<shortdoc>Delete values from a JSON serializable object and return the result. Will delete all values that match the expression.</shortdoc>
</kw>
<kw name="Get value from JSON" source="./RPA/JSON.py" lineno="267">
<arguments repr="doc: Dict[str, typing.Any] | List[typing.Any] | str | int | float | bool | None, expr: str, default: Any | None = None">
<arg kind="POSITIONAL_OR_NAMED" required="true" repr="doc: Dict[str, typing.Any] | List[typing.Any] | str | int | float | bool | None">
<name>doc</name>
<type>Dict[str, typing.Any]</type>
<type>List[typing.Any]</type>
<type>str</type>
<type>int</type>
<type>float</type>
<type>bool</type>
<type>None</type>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="true" repr="expr: str">
<name>expr</name>
<type>str</type>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="default: Any | None = None">
<name>default</name>
<type>Any</type>
<type>None</type>
<default>None</default>
</arg>
</arguments>
<doc>Get a single value from a JSON serializable object that matches the given expression.

Raises a ValueError if there is more than one match.
Returns the given default argument (or None) if there
were no matches.

:param doc: JSON serializable object or string
:param expr: jsonpath expression
:return: string containg the match OR None if no matches
:raises ValueError: if more than one match

Example:

.. code:: robotframework

   # Get the name value for the first person
   &amp;{people}=    Convert string to JSON   {"People": [{"Name": "Mark"}, {"Name": "Jane"}]}
   ${first}=     Get value from JSON      ${people}   $.People[0].Name</doc>
<shortdoc>Get a single value from a JSON serializable object that matches the given expression.</shortdoc>
</kw>
<kw name="Get values from JSON" source="./RPA/JSON.py" lineno="304">
<arguments repr="doc: Dict[str, typing.Any] | List[typing.Any] | str | int | float | bool | None, expr: str">
<arg kind="POSITIONAL_OR_NAMED" required="true" repr="doc: Dict[str, typing.Any] | List[typing.Any] | str | int | float | bool | None">
<name>doc</name>
<type>Dict[str, typing.Any]</type>
<type>List[typing.Any]</type>
<type>str</type>
<type>int</type>
<type>float</type>
<type>bool</type>
<type>None</type>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="true" repr="expr: str">
<name>expr</name>
<type>str</type>
</arg>
</arguments>
<doc>Get all values from a JSON serializable object that match the given expression.

:param doc: JSON serializable object or string
:param expr: JSONPath expression
:return: list of values that match

Example:

.. code:: robotframework

   # Get all the names for all people
   &amp;{people}=    Convert string to JSON   {"People": [{"Name": "Mark"}, {"Name": "Jane"}]}
   @{names}=     Get values from JSON     ${people}   $.People[*].Name</doc>
<shortdoc>Get all values from a JSON serializable object that match the given expression.</shortdoc>
</kw>
<kw name="Load JSON from file" source="./RPA/JSON.py" lineno="142">
<arguments repr="filename: str, encoding=utf-8">
<arg kind="POSITIONAL_OR_NAMED" required="true" repr="filename: str">
<name>filename</name>
<type>str</type>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="encoding=utf-8">
<name>encoding</name>
<default>utf-8</default>
</arg>
</arguments>
<doc>Load JSON data from a file, and return it as JSON serializable object.
Depending on the input file the object can be either a dictionary,
a list, or a scalar value.

:param filename: path to input file
:param encoding: file character encoding
:return: JSON serializable object of the JSON file

Example:

.. code:: robotframework

   &amp;{auth}=    Load JSON from file    auth.json
   Log   Current auth token: ${auth.token}</doc>
<shortdoc>Load JSON data from a file, and return it as JSON serializable object. Depending on the input file the object can be either a dictionary, a list, or a scalar value.</shortdoc>
</kw>
<kw name="Save JSON to file" source="./RPA/JSON.py" lineno="164">
<arguments repr="doc: Dict[str, typing.Any] | List[typing.Any] | str | int | float | bool | None, filename: str, indent: int | None = None, encoding: str = utf-8">
<arg kind="POSITIONAL_OR_NAMED" required="true" repr="doc: Dict[str, typing.Any] | List[typing.Any] | str | int | float | bool | None">
<name>doc</name>
<type>Dict[str, typing.Any]</type>
<type>List[typing.Any]</type>
<type>str</type>
<type>int</type>
<type>float</type>
<type>bool</type>
<type>None</type>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="true" repr="filename: str">
<name>filename</name>
<type>str</type>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="indent: int | None = None">
<name>indent</name>
<type>int</type>
<type>None</type>
<default>None</default>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="encoding: str = utf-8">
<name>encoding</name>
<type>str</type>
<default>utf-8</default>
</arg>
</arguments>
<doc>Save a JSON serializable object or a string containg
a JSON value into a file.

:param doc: JSON serializable object or string
:param filename: path to output file
:param indent: if given this value is used for json file indent
:param encoding: file character encoding

Example:

.. code:: robotframework

   # Save dictionary to file
   ${john}=    Create dictionary    name=John    mail=john@example.com
   Save JSON to file    ${john}    john.json

   # Save string to file
   ${mark}=    Set variable    {"name": "Mark", "mail": "mark@example.com"}
   Save JSON to file    ${mark}    mark.json</doc>
<shortdoc>Save a JSON serializable object or a string containg a JSON value into a file.</shortdoc>
</kw>
<kw name="Update value to JSON" source="./RPA/JSON.py" lineno="324">
<arguments repr="doc: Dict[str, typing.Any] | List[typing.Any] | str | int | float | bool | None, expr: str, value: Dict[str, typing.Any] | List[typing.Any] | str | int | float | bool | None">
<arg kind="POSITIONAL_OR_NAMED" required="true" repr="doc: Dict[str, typing.Any] | List[typing.Any] | str | int | float | bool | None">
<name>doc</name>
<type>Dict[str, typing.Any]</type>
<type>List[typing.Any]</type>
<type>str</type>
<type>int</type>
<type>float</type>
<type>bool</type>
<type>None</type>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="true" repr="expr: str">
<name>expr</name>
<type>str</type>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="true" repr="value: Dict[str, typing.Any] | List[typing.Any] | str | int | float | bool | None">
<name>value</name>
<type>Dict[str, typing.Any]</type>
<type>List[typing.Any]</type>
<type>str</type>
<type>int</type>
<type>float</type>
<type>bool</type>
<type>None</type>
</arg>
</arguments>
<doc>Update existing values in a JSON serializable object and return the result.
Will change all values that match the expression.

:param doc: JSON or string
:param expr: JSONPath expression
:param value: New value for the matching item(s)
:return: JSON serializable object with updated results

Example:

.. code:: robotframework

   # Change the name key for all people
   &amp;{before}=    Convert string to JSON   {"People": [{"Name": "Mark"}, {"Name": "Jane"}]}
   &amp;{after}=     Update value to JSON     ${before}   $.People[*].Name    JohnMalkovich</doc>
<shortdoc>Update existing values in a JSON serializable object and return the result. Will change all values that match the expression.</shortdoc>
</kw>
</keywords>
<datatypes>
</datatypes>
</keywordspec>
