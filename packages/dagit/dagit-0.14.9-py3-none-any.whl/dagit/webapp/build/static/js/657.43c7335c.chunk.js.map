{"version":3,"file":"static/js/657.43c7335c.chunk.js","mappings":"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","sources":["../../core/src/asset-graph/Utils.tsx","../../core/src/asset-graph/layout.ts","../../core/src/app/titleOfIO.ts","../../core/src/graph/layout.ts","../../core/src/workers/dagre_layout.worker.ts"],"sourcesContent":["import {gql} from '@apollo/client';\nimport {pathVerticalDiagonal} from '@vx/shape';\n\nimport {AssetNodeDefinitionFragment} from '../assets/types/AssetNodeDefinitionFragment';\n\nimport {AssetGraphLiveQuery_assetNodes_assetMaterializations} from './types/AssetGraphLiveQuery';\nimport {\n  AssetGraphQuery_assetNodes,\n  AssetGraphQuery_assetNodes_assetKey,\n} from './types/AssetGraphQuery';\nimport {AssetNodeLiveFragment} from './types/AssetNodeLiveFragment';\nimport {\n  RepositoryLiveFragment,\n  RepositoryLiveFragment_latestRunByStep_JobRunsCount,\n  RepositoryLiveFragment_latestRunByStep_LatestRun_run,\n} from './types/RepositoryLiveFragment';\n\ntype AssetNode = AssetGraphQuery_assetNodes;\ntype AssetKey = AssetGraphQuery_assetNodes_assetKey;\n\nexport const __ASSET_GROUP_PREFIX = '__ASSET_GROUP';\n\nexport function isAssetGroup(jobName: string) {\n  return jobName.startsWith(__ASSET_GROUP_PREFIX);\n}\n\n// IMPORTANT: We use this, rather than AssetNode.id throughout this file because\n// the GraphQL interface exposes dependencyKeys, not dependencyIds. We also need\n// ways to \"build\" GraphId's locally, they can't always be server-provided.\n//\n// This value is NOT the same as AssetNode.id values provided by the server,\n// because JSON.stringify's whitespace behavior is different than Python's.\n//\nexport type GraphId = string;\nexport const toGraphId = (key: AssetKey): GraphId => JSON.stringify(key.path);\n\nexport interface GraphNode {\n  id: GraphId;\n  assetKey: AssetKey;\n  definition: AssetNode;\n}\n\nexport interface GraphData {\n  nodes: {[assetId: GraphId]: GraphNode};\n  downstream: {[assetId: GraphId]: {[childAssetId: GraphId]: boolean}};\n  upstream: {[assetId: GraphId]: {[parentAssetId: GraphId]: boolean}};\n}\nexport const isSourceAsset = (node: {jobNames: string[]; opName: string | null}) => {\n  return node.jobNames.length === 0 && !node.opName;\n};\n\nexport const buildGraphData = (assetNodes: AssetNode[]) => {\n  const data: GraphData = {\n    nodes: {},\n    downstream: {},\n    upstream: {},\n  };\n\n  const addEdge = (upstreamGraphId: string, downstreamGraphId: string) => {\n    data.downstream[upstreamGraphId] = {\n      ...(data.downstream[upstreamGraphId] || {}),\n      [downstreamGraphId]: true,\n    };\n    data.upstream[downstreamGraphId] = {\n      ...(data.upstream[downstreamGraphId] || {}),\n      [upstreamGraphId]: true,\n    };\n  };\n\n  assetNodes.forEach((definition: AssetNode) => {\n    const id = toGraphId(definition.assetKey);\n    definition.dependencyKeys.forEach((key) => {\n      addEdge(toGraphId(key), id);\n    });\n    definition.dependedByKeys.forEach((key) => {\n      addEdge(id, toGraphId(key));\n    });\n\n    data.nodes[id] = {\n      id: id,\n      assetKey: definition.assetKey,\n      definition,\n    };\n  });\n\n  return data;\n};\n\nexport const buildGraphDataFromSingleNode = (assetNode: AssetNodeDefinitionFragment) => {\n  const id = toGraphId(assetNode.assetKey);\n  const graphData: GraphData = {\n    downstream: {\n      [id]: {},\n    },\n    nodes: {\n      [id]: {\n        id: id,\n        assetKey: assetNode.assetKey,\n        definition: {...assetNode, dependencyKeys: [], dependedByKeys: []},\n      },\n    },\n    upstream: {\n      [id]: {},\n    },\n  };\n\n  for (const {asset} of assetNode.dependencies) {\n    const depId = toGraphId(asset.assetKey);\n    graphData.upstream[id][depId] = true;\n    graphData.downstream[depId] = {...graphData.downstream[depId], [id]: true};\n    graphData.nodes[depId] = {\n      id: depId,\n      assetKey: asset.assetKey,\n      definition: {...asset, dependencyKeys: [], dependedByKeys: []},\n    };\n  }\n  for (const {asset} of assetNode.dependedBy) {\n    const depId = toGraphId(asset.assetKey);\n    graphData.upstream[depId] = {...graphData.upstream[depId], [id]: true};\n    graphData.downstream[id][depId] = true;\n    graphData.nodes[depId] = {\n      id: depId,\n      assetKey: asset.assetKey,\n      definition: {...asset, dependencyKeys: [], dependedByKeys: []},\n    };\n  }\n  return graphData;\n};\n\nexport const graphHasCycles = (graphData: GraphData) => {\n  const nodes = new Set(Object.keys(graphData.nodes));\n  const search = (stack: string[], node: string): boolean => {\n    if (stack.indexOf(node) !== -1) {\n      return true;\n    }\n    if (nodes.delete(node) === true) {\n      const nextStack = stack.concat(node);\n      return Object.keys(graphData.downstream[node] || {}).some((nextNode) =>\n        search(nextStack, nextNode),\n      );\n    }\n    return false;\n  };\n  let hasCycles = false;\n  while (nodes.size !== 0) {\n    hasCycles = hasCycles || search([], nodes.values().next().value);\n  }\n  return hasCycles;\n};\n\nexport const buildSVGPath = pathVerticalDiagonal({\n  source: (s: any) => s.source,\n  target: (s: any) => s.target,\n  x: (s: any) => s.x,\n  y: (s: any) => s.y,\n});\n\nexport type Status = 'good' | 'old' | 'none' | 'unknown';\n\nexport interface LiveDataForNode {\n  computeStatus: Status;\n  unstartedRunIds: string[]; // run in progress and step not started\n  inProgressRunIds: string[]; // run in progress and step in progress\n  runsSinceMaterialization: RepositoryLiveFragment_latestRunByStep_JobRunsCount | null;\n  runWhichFailedToMaterialize: RepositoryLiveFragment_latestRunByStep_LatestRun_run | null;\n  lastMaterialization: AssetGraphLiveQuery_assetNodes_assetMaterializations | null;\n  lastStepStart: number;\n}\nexport interface LiveData {\n  [assetId: GraphId]: LiveDataForNode;\n}\n\nexport const buildLiveData = (\n  graph: GraphData,\n  nodes: AssetNodeLiveFragment[],\n  repos: RepositoryLiveFragment[],\n) => {\n  const data: LiveData = {};\n\n  for (const liveNode of nodes) {\n    const graphId = toGraphId(liveNode.assetKey);\n    const graphNode = graph.nodes[graphId];\n    if (!graphNode) {\n      console.warn(`buildLiveData could not find the graph node matching ${graphId}`);\n      continue;\n    }\n\n    const lastMaterialization = liveNode.assetMaterializations[0] || null;\n    const lastStepStart = lastMaterialization?.stepStats?.startTime || 0;\n    const isPartitioned = graphNode.definition.partitionDefinition;\n    const repo = repos.find(\n      (r) =>\n        r.location.name === liveNode.repository.location.name &&\n        r.name === liveNode.repository.name,\n    );\n\n    const runs = repo?.inProgressRunsByStep.find((r) => r.stepKey === liveNode.opName);\n    const info = repo?.latestRunByStep.find((r) => r.stepKey === liveNode.opName);\n\n    const runsSinceMaterialization = info?.__typename === 'JobRunsCount' ? info : null;\n    const latestRunForStepKey = info?.__typename === 'LatestRun' ? info.run : null;\n\n    const runWhichFailedToMaterialize =\n      (!runsSinceMaterialization &&\n        latestRunForStepKey?.status === 'FAILURE' &&\n        (!lastMaterialization || lastMaterialization.runId !== latestRunForStepKey?.id) &&\n        latestRunForStepKey) ||\n      null;\n\n    data[graphId] = {\n      lastStepStart,\n      lastMaterialization,\n      inProgressRunIds: runs?.inProgressRuns.map((r) => r.id) || [],\n      unstartedRunIds: runs?.unstartedRuns.map((r) => r.id) || [],\n      runsSinceMaterialization,\n      runWhichFailedToMaterialize,\n      computeStatus: isSourceAsset(graphNode.definition)\n        ? 'good' // foreign nodes are always considered up-to-date\n        : isPartitioned\n        ? // partitioned nodes are not supported, need to compare materializations\n          // of the same partition key and the API does not make fetching this easy\n          'none'\n        : lastMaterialization\n        ? 'unknown' // resolve to 'good' or 'old' by looking upstream\n        : 'none',\n    };\n  }\n\n  for (const liveNodeId of Object.keys(data)) {\n    data[liveNodeId].computeStatus = findComputeStatusForId(data, graph.upstream, liveNodeId);\n  }\n\n  return data;\n};\n\nfunction findComputeStatusForId(\n  data: LiveData,\n  upstream: {[assetId: string]: {[upstreamAssetId: string]: boolean}},\n  assetId: string,\n): Status {\n  if (!data[assetId]) {\n    // Currently compute status assumes foreign nodes are up to date\n    // and only shows \"upstream changed\" for upstreams in the same job\n    return 'good';\n  }\n  const ts = data[assetId].lastStepStart;\n  const upstreamIds = Object.keys(upstream[assetId] || {});\n  if (data[assetId].computeStatus !== 'unknown') {\n    return data[assetId].computeStatus;\n  }\n\n  return upstreamIds.some((uid) => data[uid]?.lastStepStart > ts)\n    ? 'old'\n    : upstreamIds.some((uid) => findComputeStatusForId(data, upstream, uid) !== 'good')\n    ? 'old'\n    : 'good';\n}\n\nexport function tokenForAssetKey(key: {path: string[]}) {\n  return key.path.join('>');\n}\n\nexport function displayNameForAssetKey(key: {path: string[]}) {\n  return key.path.join(' > ');\n}\n\nexport const IN_PROGRESS_RUNS_FRAGMENT = gql`\n  fragment InProgressRunsFragment on InProgressRunsByStep {\n    stepKey\n    unstartedRuns {\n      id\n    }\n    inProgressRuns {\n      id\n    }\n  }\n`;\n\nexport const LAST_RUNS_WARNINGS_FRAGMENT = gql`\n  fragment LastRunsWarningsFragment on RunStatsByStep {\n    __typename\n    ... on LatestRun {\n      stepKey\n      run {\n        id\n        status\n      }\n    }\n    ... on JobRunsCount {\n      stepKey\n      jobNames\n      count\n      sinceLatestMaterialization\n    }\n  }\n`;\n\nexport const REPOSITORY_LIVE_FRAGMENT = gql`\n  fragment RepositoryLiveFragment on Repository {\n    id\n    name\n    location {\n      id\n      name\n    }\n    inProgressRunsByStep {\n      ...InProgressRunsFragment\n    }\n    latestRunByStep {\n      __typename\n      ...LastRunsWarningsFragment\n    }\n  }\n  ${IN_PROGRESS_RUNS_FRAGMENT}\n  ${LAST_RUNS_WARNINGS_FRAGMENT}\n`;\n","import * as dagre from 'dagre';\n\nimport {IBounds, IPoint} from '../graph/common';\n\nimport {GraphData, GraphNode, GraphId, displayNameForAssetKey} from './Utils';\n\nexport interface AssetLayout {\n  id: GraphId;\n\n  // Overall frame of the box relative to 0,0 on the graph\n  bounds: IBounds;\n}\n\nexport type AssetLayoutEdge = {\n  from: IPoint;\n  to: IPoint;\n  dashed: boolean;\n};\n\nexport type AssetGraphLayout = {\n  width: number;\n  height: number;\n  edges: AssetLayoutEdge[];\n  nodes: {[id: string]: AssetLayout};\n};\n\nconst opts: {margin: number; mini: boolean} = {\n  margin: 100,\n  mini: false,\n};\n\nexport const layoutAssetGraph = (graphData: GraphData): AssetGraphLayout => {\n  const g = new dagre.graphlib.Graph();\n\n  g.setGraph({\n    rankdir: 'TB',\n    marginx: opts.margin,\n    marginy: opts.margin,\n    nodesep: opts.mini ? 20 : 50,\n    edgesep: opts.mini ? 10 : 10,\n    ranksep: opts.mini ? 20 : 50,\n  });\n  g.setDefaultEdgeLabel(() => ({}));\n\n  const shouldRender = (node?: GraphNode) => node && node.definition.opName;\n\n  Object.values(graphData.nodes)\n    .filter(shouldRender)\n    .forEach((node) => {\n      const {width, height} = getAssetNodeDimensions(node.definition);\n      g.setNode(node.id, {width: opts.mini ? 230 : width, height});\n    });\n\n  const foreignNodes = {};\n  Object.keys(graphData.downstream).forEach((upstreamId) => {\n    const downstreamIds = Object.keys(graphData.downstream[upstreamId]);\n    downstreamIds.forEach((downstreamId) => {\n      if (\n        !shouldRender(graphData.nodes[downstreamId]) &&\n        !shouldRender(graphData.nodes[upstreamId])\n      ) {\n        return;\n      }\n      g.setEdge({v: upstreamId, w: downstreamId}, {weight: 1});\n\n      if (!shouldRender(graphData.nodes[downstreamId])) {\n        foreignNodes[downstreamId] = true;\n      } else if (!shouldRender(graphData.nodes[upstreamId])) {\n        foreignNodes[upstreamId] = true;\n      }\n    });\n  });\n\n  Object.keys(foreignNodes).forEach((id) => {\n    g.setNode(id, getForeignNodeDimensions(id));\n  });\n\n  dagre.layout(g);\n\n  const dagreNodesById: {[id: string]: dagre.Node} = {};\n  g.nodes().forEach((id) => {\n    const node = g.node(id);\n    if (!node) {\n      return;\n    }\n    dagreNodesById[id] = node;\n  });\n\n  let maxWidth = 0;\n  let maxHeight = 0;\n  const nodes: {[id: string]: AssetLayout} = {};\n  Object.keys(dagreNodesById).forEach((id) => {\n    const dagreNode = dagreNodesById[id];\n    nodes[id] = {\n      id,\n      bounds: {\n        x: dagreNode.x - dagreNode.width / 2,\n        y: dagreNode.y - dagreNode.height / 2,\n        width: dagreNode.width,\n        height: dagreNode.height,\n      },\n    };\n    maxWidth = Math.max(maxWidth, dagreNode.x + dagreNode.width / 2);\n    maxHeight = Math.max(maxHeight, dagreNode.y + dagreNode.height / 2);\n  });\n\n  const edges: AssetLayoutEdge[] = [];\n  g.edges().forEach((e) => {\n    const points = g.edge(e).points;\n    edges.push({\n      from: points[0],\n      to: points[points.length - 1],\n      dashed: false,\n    });\n  });\n\n  return {\n    nodes,\n    edges,\n    width: maxWidth + opts.margin,\n    height: maxHeight + opts.margin,\n  };\n};\n\nexport const getForeignNodeDimensions = (id: string) => {\n  const path = JSON.parse(id);\n  return {width: displayNameForAssetKey({path}).length * 8 + 30, height: 30};\n};\n\nexport const getAssetNodeDimensions = (def: {\n  assetKey: {path: string[]};\n  opName: string | null;\n  description?: string | null;\n}) => {\n  let height = 95;\n  if (def.description) {\n    height += 25;\n  }\n  const displayName = displayNameForAssetKey(def.assetKey);\n  if (def.opName && displayName !== def.opName) {\n    height += 25;\n  }\n  return {width: Math.max(250, displayName.length * 8.0) + 25, height};\n};\n","export const DEFAULT_RESULT_NAME = 'result';\n\nexport const titleOfIO = (i: {solid: {name: string}; definition: {name: string}}) => {\n  return i.solid.name !== DEFAULT_RESULT_NAME\n    ? `${i.solid.name}:${i.definition.name}`\n    : i.solid.name;\n};\n","import * as dagre from 'dagre';\n\nimport {titleOfIO} from '../app/titleOfIO';\n\nimport {IBounds, IPoint} from './common';\n\ntype OpLayoutEdgeSide = {\n  point: IPoint;\n  opName: string;\n  edgeName: string;\n};\n\nexport type OpLayoutEdge = {\n  from: OpLayoutEdgeSide;\n  to: OpLayoutEdgeSide;\n};\n\nexport interface OpLayout {\n  // Overall frame of the box relative to 0,0 on the graph\n  bounds: IBounds;\n\n  // Frames of specific components - These need to be computed during layout\n  // (rather than at render time) to position edges into inputs/outputs.\n  op: IBounds;\n  inputs: {\n    [inputName: string]: {\n      layout: IBounds;\n      port: IPoint;\n    };\n  };\n  outputs: {\n    [outputName: string]: {\n      layout: IBounds;\n      port: IPoint;\n    };\n  };\n}\n\nexport type OpGraphLayout = {\n  width: number;\n  height: number;\n  parent: ParentOpLayout | null;\n  edges: OpLayoutEdge[];\n  nodes: {[opName: string]: OpLayout};\n};\n\ninterface ParentOpLayout extends Omit<OpLayout, 'op'> {\n  mappingLeftEdge: number;\n  mappingLeftSpacing: number;\n  dependsOn: {[opName: string]: IPoint};\n  dependedBy: {[opName: string]: IPoint};\n  invocationBoundingBox: IBounds;\n}\n\nexport interface ILayoutOp {\n  name: string;\n  inputs: {\n    definition: {\n      name: string;\n    };\n    dependsOn: {\n      definition: {\n        name: string;\n      };\n      solid: {\n        name: string;\n      };\n    }[];\n  }[];\n  definition: {\n    description: string | null;\n    assetNodes: {\n      assetKey: {\n        path: string[];\n      };\n    }[];\n  };\n  outputs: {\n    definition: {\n      name: string;\n    };\n    dependedBy: {\n      definition: {\n        name: string;\n      };\n      solid: {\n        name: string;\n      };\n    }[];\n  }[];\n}\n\nconst MAX_PER_ROW_ENABLED = false;\nconst MAX_PER_ROW = 25;\nconst OP_WIDTH = 370;\nconst OP_BASE_HEIGHT = 52;\nconst OP_ASSETS_ROW_HEIGHT = 22;\nconst IO_HEIGHT = 26;\nconst IO_INSET = 0;\nconst IO_MINI_WIDTH = 35;\nconst IO_THRESHOLD_FOR_MINI = 4;\nconst PORT_INSET_X = 13;\nconst PORT_INSET_Y = IO_HEIGHT / 2;\nconst PARENT_DEFINITION_PADDING = 70;\nconst PARENT_INVOCATION_PADDING = 70;\nconst EXTERNAL_DEPENDENCY_PADDING = 50;\n\nconst MARGIN_BASE = 100;\n\ntype OpLinkInfo = {\n  solid: {name: string};\n  definition: {name: string};\n};\n\nfunction flattenIO(arrays: OpLinkInfo[][]) {\n  const map: {[key: string]: OpLinkInfo} = {};\n  arrays.forEach((array) => array.forEach((item) => (map[titleOfIO(item)] = item)));\n  return Object.values(map);\n}\n\nexport function layoutOpGraph(pipelineOps: ILayoutOp[], parentOp?: ILayoutOp): OpGraphLayout {\n  const g = new dagre.graphlib.Graph();\n\n  // First, identify how much space we need to pad the DAG by in order to show the\n  // parent op AROUND it. We pass this padding in to dagre, and then we have enough\n  // room to add our parent layout around the result.\n  let parentIOPadding = 0;\n  let marginy = MARGIN_BASE;\n  let marginx = MARGIN_BASE;\n  if (parentOp) {\n    parentIOPadding = Math.max(parentOp.inputs.length, parentOp.outputs.length) * IO_HEIGHT;\n    marginx = PARENT_DEFINITION_PADDING + PARENT_INVOCATION_PADDING;\n    marginy = marginx + parentIOPadding;\n  }\n\n  // Define a new top-down, left to right graph layout\n  g.setGraph({rankdir: 'TB', marginx, marginy});\n  g.setDefaultEdgeLabel(() => ({}));\n\n  const edges: OpLayoutEdge[] = [];\n  const opNamesPresent: {[name: string]: boolean} = {};\n\n  pipelineOps.forEach((op) => {\n    opNamesPresent[op.name] = true;\n  });\n  pipelineOps.forEach((op) => {\n    // Lay out each op individually to get it's width and height based on it's\n    // inputs and outputs, and then attach it to the graph. Dagre will give us it's\n    // x,y position.\n    const layout = layoutOp(op, {x: 0, y: 0});\n    g.setNode(op.name, {\n      width: layout.bounds.width,\n      height: layout.bounds.height,\n    });\n\n    // Give Dagre the dependency edges and build a flat set of them so we\n    // can reference them in a single pass later\n    op.inputs.forEach((input) => {\n      input.dependsOn.forEach((dep) => {\n        if (opNamesPresent[dep.solid.name] && opNamesPresent[op.name]) {\n          g.setEdge({v: dep.solid.name, w: op.name}, {weight: 1});\n\n          edges.push({\n            from: {\n              point: {x: 0, y: 0},\n              opName: dep.solid.name,\n              edgeName: dep.definition.name,\n            },\n            to: {\n              point: {x: 0, y: 0},\n              opName: op.name,\n              edgeName: input.definition.name,\n            },\n          });\n        }\n      });\n    });\n  });\n\n  dagre.layout(g);\n\n  const ops: {[opName: string]: OpLayout} = {};\n  const dagreNodes: {[opName: string]: dagre.Node} = {};\n  g.nodes().forEach(function (opName) {\n    const node = g.node(opName);\n    if (!node) {\n      return;\n    }\n    dagreNodes[opName] = node;\n  });\n\n  if (MAX_PER_ROW_ENABLED) {\n    const nodesInRows: {[key: string]: dagre.Node[]} = {};\n    g.nodes().forEach(function (opName) {\n      const node = g.node(opName);\n      if (!node) {\n        return;\n      }\n      nodesInRows[`${node.y}`] = nodesInRows[`${node.y}`] || [];\n      nodesInRows[`${node.y}`].push(node);\n    });\n\n    // OK! We're going to split the nodes in long (>MAX_PER_ROW) rows into\n    // multiple rows, shift all the subsequent rows down. Note we do this\n    // repeatedly until each row has less than MAX_PER_ROW nodes. There are\n    // a few caveats to this:\n    // - We may end up making the lines betwee nodes and their children\n    //   less direct.\n    // - We may \"compact\" two groups of ops separated by horizontal\n    //   whitespace on the same row into the same block.\n\n    const rows = Object.keys(nodesInRows)\n      .map((a) => Number(a))\n      .sort((a, b) => a - b);\n\n    const firstRow = nodesInRows[`${rows[0]}`];\n    const firstRowCenterX = firstRow\n      ? firstRow.reduce((s, n) => s + n.x + n.width / 2, 0) / firstRow.length\n      : 0;\n\n    for (let ii = 0; ii < rows.length; ii++) {\n      const rowKey = `${rows[ii]}`;\n      const rowNodes = nodesInRows[rowKey];\n\n      const desiredCount = Math.ceil(rowNodes.length / MAX_PER_ROW);\n      if (desiredCount === 1) {\n        continue;\n      }\n\n      for (let r = 0; r < desiredCount; r++) {\n        const newRowNodes = rowNodes.slice(r * MAX_PER_ROW, (r + 1) * MAX_PER_ROW);\n        const maxHeight = Math.max(...newRowNodes.map((n) => n.height)) + OP_BASE_HEIGHT;\n        const totalWidth = newRowNodes.reduce((sum, n) => sum + n.width + OP_BASE_HEIGHT, 0);\n\n        let x = firstRowCenterX - totalWidth / 2;\n\n        // shift the nodes before the split point so they're centered nicely\n        newRowNodes.forEach((n) => {\n          n.x = x;\n          x += n.width + OP_BASE_HEIGHT;\n        });\n\n        // shift the nodes after the split point downwards\n        const shifted = rowNodes.slice((r + 1) * MAX_PER_ROW);\n        shifted.forEach((n) => (n.y += maxHeight));\n\n        // shift all nodes in the graph beneath this row down by\n        // the height of the newly inserted row.\n        const shiftedMaxHeight = Math.max(0, ...shifted.map((n) => n.height)) + OP_BASE_HEIGHT;\n\n        for (let jj = ii + 1; jj < rows.length; jj++) {\n          nodesInRows[`${rows[jj]}`].forEach((n) => (n.y += shiftedMaxHeight));\n        }\n      }\n    }\n    let minX = Number.MAX_SAFE_INTEGER;\n    Object.keys(dagreNodes).forEach((opName) => {\n      const node = dagreNodes[opName];\n      minX = Math.min(minX, node.x - node.width / 2 - marginx);\n    });\n    Object.keys(dagreNodes).forEach((opName) => {\n      const node = dagreNodes[opName];\n      node.x -= minX;\n    });\n  }\n\n  // Due to a bug in Dagre when run without an \"align\" value, we need to calculate\n  // the total width of the graph coordinate space ourselves. We need the height\n  // because we've shifted long single rows into multiple rows.\n  let maxWidth = 0;\n  let maxHeight = 0;\n\n  // Read the Dagre layout and map \"nodes\" back to our solids, but with\n  // X,Y coordinates this time.\n  Object.keys(dagreNodes).forEach((opName) => {\n    const node = dagreNodes[opName];\n    const op = pipelineOps.find(({name}) => name === opName);\n    if (!op) {\n      return;\n    }\n\n    const x = node.x - node.width / 2; // Dagre's x/y is the center, we want top left\n    const y = node.y - node.height / 2;\n    ops[opName] = layoutOp(op, {x, y});\n    maxWidth = Math.max(maxWidth, x + node.width);\n    maxHeight = Math.max(maxHeight, y + node.height);\n  });\n\n  // Read the Dagre layout and map \"edges\" back to our data model. We don't\n  // currently use the \"closest points on the node\" Dagre suggests (but we could).\n  g.edges().forEach(function (e) {\n    const conn = edges.find((c) => c.from.opName === e.v && c.to.opName === e.w);\n    const points = g.edge(e).points;\n    if (conn) {\n      conn.from.point = points[0];\n      conn.to.point = points[points.length - 1];\n    }\n  });\n\n  const result: OpGraphLayout = {\n    edges,\n    nodes: ops,\n    width: maxWidth + marginx,\n    height: maxHeight + marginy,\n    parent: null,\n  };\n\n  if (parentOp) {\n    // Now that we've computed the pipeline layout fully, lay out the\n    // composite op around the completed DAG.\n    result.parent = layoutParentGraphOp(result, parentOp, parentIOPadding);\n  }\n\n  return result;\n}\n\nfunction layoutParentGraphOp(layout: OpGraphLayout, op: ILayoutOp, parentIOPadding: number) {\n  const result: ParentOpLayout = {\n    invocationBoundingBox: {\n      x: 1,\n      y: 1,\n      width: layout.width - 1,\n      height: layout.height - 1,\n    },\n    bounds: {\n      x: PARENT_INVOCATION_PADDING,\n      y: PARENT_INVOCATION_PADDING + parentIOPadding,\n      width: layout.width - PARENT_INVOCATION_PADDING * 2,\n      height: layout.height - (PARENT_INVOCATION_PADDING + parentIOPadding) * 2,\n    },\n    mappingLeftEdge: PARENT_INVOCATION_PADDING - 20,\n    mappingLeftSpacing: 10,\n    inputs: {},\n    outputs: {},\n    dependsOn: layoutExternalConnections(\n      flattenIO(op.inputs.map((d) => d.dependsOn)),\n      -EXTERNAL_DEPENDENCY_PADDING,\n      layout.width,\n    ),\n    dependedBy: layoutExternalConnections(\n      flattenIO(op.outputs.map((d) => d.dependedBy)),\n      layout.height + EXTERNAL_DEPENDENCY_PADDING,\n      layout.width,\n    ),\n  };\n\n  const boundingBottom = result.bounds.y + result.bounds.height;\n\n  op.inputs.forEach((input, idx) => {\n    result.inputs[input.definition.name] = {\n      layout: {\n        x: result.bounds.x,\n        y: result.bounds.y - idx * IO_HEIGHT - IO_HEIGHT,\n        width: 0,\n        height: IO_HEIGHT,\n      },\n      port: {\n        x: result.bounds.x + PORT_INSET_X,\n        y: result.bounds.y - idx * IO_HEIGHT - IO_HEIGHT / 2,\n      },\n    };\n  });\n\n  op.outputs.forEach((output, idx) => {\n    result.outputs[output.definition.name] = {\n      layout: {\n        x: result.bounds.x,\n        y: boundingBottom + idx * IO_HEIGHT,\n        width: 0,\n        height: IO_HEIGHT,\n      },\n      port: {\n        x: result.bounds.x + PORT_INSET_X,\n        y: boundingBottom + idx * IO_HEIGHT + IO_HEIGHT / 2,\n      },\n    };\n  });\n\n  return result;\n}\n\nfunction layoutExternalConnections(links: OpLinkInfo[], y: number, layoutWidth: number) {\n  // fill evenly from 0 to layoutWidth from left to right, then center them if there's overflow.\n  const inset = PARENT_INVOCATION_PADDING + PORT_INSET_X;\n  const insetWidth = layoutWidth - inset * 2;\n  const spacing = Math.max(200, insetWidth / links.length);\n  const baseX = inset + Math.min(0, (insetWidth - links.length * spacing) / 2);\n  const yShift = spacing < 300 ? 20 : 0;\n\n  const result: {[opName: string]: IPoint} = {};\n  links.forEach((link, idx) => {\n    const shiftDirection = 1 - (idx % 2) * 2; // 1 or -1, alternating\n    result[titleOfIO(link)] = {\n      x: baseX + idx * spacing,\n      y: y + yShift * shiftDirection,\n    };\n  });\n  return result;\n}\n\nexport function layoutOp(op: ILayoutOp, root: IPoint): OpLayout {\n  // Starting at the root (top left) X,Y, return the layout information for a solid with\n  // input blocks, then the main block, then output blocks (arranged vertically)\n  let accY = root.y;\n\n  const inputsLayouts: {\n    [inputName: string]: {layout: IBounds; port: IPoint};\n  } = {};\n\n  const buildIOSmallLayout = (idx: number, count: number) => {\n    const centeringOffsetX = (OP_WIDTH - IO_MINI_WIDTH * count) / 2;\n    const x = root.x + IO_MINI_WIDTH * idx + centeringOffsetX;\n    return {\n      port: {\n        x: x + PORT_INSET_X,\n        y: accY + PORT_INSET_Y,\n      },\n      layout: {\n        x: x,\n        y: accY,\n        width: IO_MINI_WIDTH,\n        height: IO_HEIGHT,\n      },\n    };\n  };\n\n  const buildIOLayout = () => {\n    const layout: {layout: IBounds; port: IPoint} = {\n      port: {x: root.x + PORT_INSET_X, y: accY + PORT_INSET_Y},\n      layout: {\n        x: root.x,\n        y: accY,\n        width: 0,\n        height: IO_HEIGHT,\n      },\n    };\n    accY += IO_HEIGHT;\n    return layout;\n  };\n\n  op.inputs.forEach((input, idx) => {\n    inputsLayouts[input.definition.name] =\n      op.inputs.length > IO_THRESHOLD_FOR_MINI\n        ? buildIOSmallLayout(idx, op.inputs.length)\n        : buildIOLayout();\n  });\n  if (op.inputs.length > IO_THRESHOLD_FOR_MINI) {\n    accY += IO_HEIGHT;\n  }\n\n  const opLayout: IBounds = {\n    x: root.x,\n    y: Math.max(root.y, accY - IO_INSET),\n    width: OP_WIDTH,\n    height: OP_BASE_HEIGHT + IO_INSET * 2,\n  };\n\n  accY += OP_BASE_HEIGHT;\n\n  if (op.definition.assetNodes.length && op.definition.description) {\n    opLayout.height += OP_ASSETS_ROW_HEIGHT;\n    accY += OP_ASSETS_ROW_HEIGHT;\n  }\n\n  const outputLayouts: {\n    [outputName: string]: {\n      layout: IBounds;\n      port: IPoint;\n    };\n  } = {};\n\n  op.outputs.forEach((output, idx) => {\n    outputLayouts[output.definition.name] =\n      op.outputs.length > IO_THRESHOLD_FOR_MINI\n        ? buildIOSmallLayout(idx, op.outputs.length)\n        : buildIOLayout();\n  });\n  if (op.outputs.length > IO_THRESHOLD_FOR_MINI) {\n    accY += IO_HEIGHT;\n  }\n\n  return {\n    bounds: {\n      x: root.x - 5,\n      y: root.y - 5,\n      width: OP_WIDTH + 10,\n      height: accY - root.y + 10,\n    },\n    op: opLayout,\n    inputs: inputsLayouts,\n    outputs: outputLayouts,\n  };\n}\n","/* eslint-disable no-restricted-globals */\n\n/**\n * NOTE: Please avoid adding React as a transitive dependency to this file, as it can break\n * the development workflow. https://github.com/pmmmwh/react-refresh-webpack-plugin/issues/24\n *\n * If you see an error like `$RefreshReg$ is not defined` during development, check the\n * dependencies of this file. If you find that React has been included as a dependency, please\n * try to remove it.\n */\n\nimport {layoutAssetGraph} from '../asset-graph/layout';\nimport {layoutOpGraph} from '../graph/layout';\nconst ctx: Worker = self as any;\n\nctx.addEventListener('message', (event) => {\n  if (event.data.type === 'layoutOpGraph') {\n    const {ops, parentOp} = event.data;\n    ctx.postMessage(layoutOpGraph(ops, parentOp));\n  } else if (event.data.type === 'layoutAssetGraph') {\n    const {graphData} = event.data;\n    ctx.postMessage(layoutAssetGraph(graphData));\n  }\n});\n"],"names":["pathVerticalDiagonal","source","s","target","x","y","displayNameForAssetKey","key","path","join","IN_PROGRESS_RUNS_FRAGMENT","gql","LAST_RUNS_WARNINGS_FRAGMENT","opts","getForeignNodeDimensions","id","width","JSON","parse","length","height","getAssetNodeDimensions","def","description","displayName","assetKey","opName","Math","max","titleOfIO","i","solid","name","definition","OP_BASE_HEIGHT","IO_HEIGHT","PORT_INSET_X","PARENT_INVOCATION_PADDING","flattenIO","arrays","map","forEach","array","item","Object","values","layoutOpGraph","pipelineOps","parentOp","g","dagre","graphlib","Graph","parentIOPadding","marginy","marginx","inputs","outputs","PARENT_DEFINITION_PADDING","setGraph","rankdir","setDefaultEdgeLabel","edges","opNamesPresent","op","layout","layoutOp","setNode","bounds","input","dependsOn","dep","setEdge","v","w","weight","push","from","point","edgeName","to","ops","dagreNodes","nodes","node","maxWidth","maxHeight","keys","find","e","conn","c","points","edge","result","parent","invocationBoundingBox","mappingLeftEdge","mappingLeftSpacing","layoutExternalConnections","d","dependedBy","boundingBottom","idx","port","output","layoutParentGraphOp","links","layoutWidth","insetWidth","inset","spacing","baseX","min","yShift","link","shiftDirection","root","accY","inputsLayouts","buildIOSmallLayout","count","centeringOffsetX","buildIOLayout","opLayout","assetNodes","outputLayouts","OP_WIDTH","ctx","self","addEventListener","event","data","type","postMessage","graphData","nodesep","edgesep","ranksep","shouldRender","filter","foreignNodes","downstream","upstreamId","downstreamId","dagreNodesById","dagreNode","dashed","layoutAssetGraph"],"sourceRoot":""}