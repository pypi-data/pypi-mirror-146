# -*- coding: utf-8 -*-
from setuptools import setup

package_dir = \
{'': 'src'}

packages = \
['hotedit', 'tests']

package_data = \
{'': ['*']}

extras_require = \
{'test': ['pytest>=6.2,<7.0', 'pytest-flakes>=4.0.5,<5.0.0']}

setup_kwargs = {
    'name': 'hotedit',
    'version': '0.9.1.post1',
    'description': 'Automatically find and launch an editor with a stream of text to edit; then save',
    'long_description': '# hotedit\n\nA simple library for opening your user\'s favorite text editor\n\nThe `hotedit()` API looks at a few places in the shell environment for\na useful text editor, invokes it with your text, and finally returns\nthe edited result to your program (or raises an exception if an error \noccurred invoking the editor). \n\n## Install\n\n```shell\npip install hotedit\n```\n\n### Installation for maintainers\n\nAfter checking out github source, work with it using [Poetry].\n\n1. Install `poetry`: \n  ```\n  curl -sSL https://install.python-poetry.org | python3 -\n  ```\n\n2. Activate your poetry shell in the git repo you checked out, and install dependencies:\n  ```\n  poetry shell\n  ...\n\n  poetry install -E test\n  ```\n\n3. Run tests:\n  ```\n  make test\n  ```\n\n[poetry]: https://python-poetry.org\n\n## Use\n\n```python\n# Get a string from the Internet so we can edit it:\nimport requests\nURL = "https://pastebin.com/raw/Df9NAmYc"\nresponse = requests.get(URL)\n\n"""\nCall `hotedit()` to launch the text editor to edit what was in the pastebin\ndocument.\n\nThe first argument `initial` is the string to be shown in your editing buffer.\nThis creates a temp file, later deleted.\n\nOther useful arguments:\n  - validate_unchanged (default False): When True, raise `Unchanged` exception when\n    the user did not make any edits.\n  - delete_temp (default True): When False, doesn\'t delete the temp file (for \n    troubleshooting).\n  - find_editor (default `hotedit.editor.determine_editor`): a zero-argument\n    callable that returns the path to an editor executable (see below)\n"""\nfrom hotedit import hotedit\nedited = hotedit(response.text)\n# `edited` is the string returned from editing.\n\nprint("Your edited text:")\nfor line in edited.splitlines():\n    print(f"> {line}")\n\n# At this point we might upload the new string back to pastebin.\n```\n\n## How it determines your editor\n\nHotedit looks at your shell environment to determine which editor you\'re using.\n\nIt follows some very simple rules.\n\n1. Check the following in order for a useful editor:\n    1. `git config core.editor`\n    1. `EDITOR` environment variable\n    1. `VISUAL` environment variable\n\n2. If one of these is a string, that string is returned as the path to an editor.\n\n3. `hotedit()` itself will raise an exception if the path returned is not an\n   editor executable, but it does not keep trying other options if this happens.\n\nThis means if `core.editor` is unset, `$EDITOR` is set to a path that\'s missing,\nand `$VISUAL` is set to a valid path to an editor, `hotedit` will use `$EDITOR`\nand fail, without checking `$VISUAL`.\n\n### Overriding editor search with `find_editor`\n\nIf you don\'t like hotedit\'s search order, you can pass your own `find_editor`\nfunction. Commonly, you want to try a different location first, then try the\ndefault options. Here\'s an implementation of that:\n\n```python\nimport os\nimport hotedit, hotedit.editor\n\ndef my_find_editor():\n    if os.environ.get("MY_APP_TEXT_EDITOR"):\n        return os.environ["MY_APP_TEXT_EDITOR"]\n    return hotedit.editor.determine_editor()\n\nedited = hotedit.hotedit("[MY_APP config]...", find_editor=my_find_editor)\n...\n```\n\n\n## Suggestions for setting your editor\n\nMany editor values _just work_, especially if they are commonly used in the\nterminal. For example, you can just set `EDITOR=nano` or `EDITOR=vim`.\n\nEditors that open in their own window, or make use of an already-open window,\nalmost always provide a command-line option for exactly the use cases\nhotedit is used for. For example, try the following:\n\n(Open a new gvim window, or open a tab in an existing gvim window, respectively):\n```\nEDITOR="gvim -f"  # or\nEDITOR="gvim --remote-tab-wait"\n```\n\n(Open a tab in VS Code):\n```\nEDITOR="code -w"\n```\n\nIf your users are likely to be using git, the best experience for them is usually\nto invoke an editor the same way git would invoke one to ask for a commit\nmessage. While it\'s not up to the `hotedit` library to tell you how to live your\nlife, here\'s how you would do that:\n\n```\n# VS code, for example\ngit config core.editor "code -w"\n```\n\n----\n\n## Maintainer section: releasing\n\nTo cut a release of this software, automated tests must pass. Check under `Actions` for the latest commit.\n\n#### Create an RC branch and test\n\n- We use the Gitflow process. For a release, this means that you should have a v1.2.3-rc branch under your \n  develop branch. Like this:\n  ```\n    main  \n    └── develop  \n        └── v1.2.3-rc\n  ```\n\n- Update *this file*.\n  \n  1. Confirm that the docs make sense for the current release.\n  1. Check links!\n  1. Update the Changelog section at the bottom.\n\n- Perform whatever tests are necessary.\n\n#### Tag and cut the release with Github Actions\n\n- Once you have tested in this branch, create a tag in the v1.2.3-rc branch:\n  ```\n  git tag -a -m v1.2.3 v1.2.3\n  git push --tags\n  ```\n\n- Navigate to https://github.com/corydodt/hotedit/actions and run the action labeled `... release`.\n\n    - You will be asked to choose a branch. Choose your rc branch, e.g. `v1.2.3-rc`\n\n    - If you run this action without creating a tag on v1.2.3-rc first, the action will fail with an error and nothing will happen.\n\n  If you have correctly tagged a commit and chosen the right branch, this will run and create a new release on the [Releases page].\n\n- Edit the release on that page \n\n#### Merge up\n\n- Finish up by merging your `-rc` branch into \n  1. `main` and then \n  2. `develop`.\n\n## Changelog\n\n<details><summary>(About: Keep-a-Changelog text format)</summary>\n\nThe format is based on [Keep a Changelog], and this project adheres to [Semantic\nVersioning].\n</details>\n\n### versions [0.9.1]\n\n- Initial public release.\n- Automated builds, automated tests.\n\n\n[Unreleased]: https://github.com/corydodt/hotedit/compare/v0.9.1..HEAD\n[0.9.1]:        https://github.com/corydodt/hotedit/compare/v0.0..v0.9.1\n[0.0]:        https://github.com/corydodt/hotedit/tree/v0.0\n\n\n[latest release]: https://github.com/corydodt/hotedit/releases/latest\n\n[Releases page]: https://github.com/corydodt/hotedit/releases\n\n[Keep a Changelog]: https://keepachangelog.com/en/1.0.0/\n\n[Semantic Versioning]: https://semver.org/spec/v2.0.0.html\n',
    'author': 'Cory Dodt',
    'author_email': '121705+corydodt@users.noreply.github.com',
    'maintainer': None,
    'maintainer_email': None,
    'url': None,
    'package_dir': package_dir,
    'packages': packages,
    'package_data': package_data,
    'extras_require': extras_require,
    'python_requires': '>=3.6.2,<4',
}


setup(**setup_kwargs)
