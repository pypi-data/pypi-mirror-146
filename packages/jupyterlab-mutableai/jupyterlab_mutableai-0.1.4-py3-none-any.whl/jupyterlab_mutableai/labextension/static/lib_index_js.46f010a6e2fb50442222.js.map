{"version":3,"file":"lib_index_js.46f010a6e2fb50442222.js","mappings":";;;;;;;;;;;;;;;AAAA;AACA;AACA;AACoD;AACpD;AACA;AACA;AACO,kCAAkC,8DAAa;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,6CAA6C,4BAA4B,uBAAuB;AAChG;AACA;AACA,CAAC,0BAA0B;;;;;;;;;;;;;;;;;;AC7D3B;AACA;AACA;AACoD;AACZ;AACxC;AACA;AACA;AACO,8BAA8B,8DAAa;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA,oBAAoB,oDAAU;AAC9B;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd,gBAAgB,mEAAmE;AACnF,gBAAgB,sDAAsD;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,0BAA0B;;;;;;;;;;;;;;;;;;;ACjHoB;AACS;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACO,kDAAkD;AACzD;AACA,qBAAqB,+EAA6B;AAClD,uBAAuB,8DAAW;AAClC;AACA;AACA;AACA,yBAAyB,8EAA4B;AACrD;AACA;AACA,kBAAkB,+EAA6B;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,gFAA8B;AAChD;AACA;AACA;;;;;;;;;;;;;;;;;;AClCgD;AACN;AACE;AAC5C;AACA;AACA;AACA;AACA,IAAI,4DAAW;AACf,IAAI,yDAAQ;AACZ,IAAI,0DAAS;AACb;AACA,iEAAe,OAAO,EAAC;;;;;;;;;;;;;;;;;;;;;;;ACXuE;AAC/B;AACP;AACM;AACE;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,gCAAgC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,qEAAkB,EAAE,kEAAgB,EAAE,yEAAgB;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC;AACtC,0CAA0C,sEAAmB;AAC7D;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,kEAAe;AAC1D,4CAA4C,mEAAgB;AAC5D;AACA;AACA;AACA;AACA;AACA,2CAA2C,wEAAe;AAC1D,gDAAgD,sEAAmB;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,6EAA6E,IAAI;AACjF;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,SAAS;AACT;AACA;AACA,iEAAe,SAAS,EAAC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC/FsC;AACD;AACF;AACN;AACG;AACJ;AACM;AACL;AACd;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,wEAAmB,EAAE,yEAAgB,EAAE,2DAAS,EAAE,gEAAW;AAC5E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,WAAW;AACnC,0CAA0C,uEAAqB;AAC/D;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA,sDAAsD,UAAU;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uEAAuE,iCAAiC;AACxG,yBAAyB;AACzB;AACA,+FAA+F,OAAO;AACtG,yBAAyB;AACzB;AACA,iBAAiB;AACjB;AACA;AACA;AACA,8CAA8C,QAAQ;AACtD,4CAA4C,6DAAc;AAC1D,2CAA2C,gEAAc,GAAG,SAAS;AACrE;AACA,4CAA4C,mEAAY;AACxD;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,0BAA0B,sEAAe;AACzC;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C;AAC7C;AACA,sCAAsC,oDAAU;AAChD;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,SAAS;AACT;AACA;AACA,iEAAe,WAAW,EAAC;;;;;;;;;;;;;;;;;ACzIoC;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,yEAAgB;AAC/B;AACA;AACA,iEAAe,QAAQ,EAAC;;;;;;;;;;;;;;;;;;;ACX2B;AACO;AACP;AACnD;AACA,YAAY,iBAAiB;AAC7B,oDAAoD,+CAAQ;AAC5D,gCAAgC,+CAAQ;AACxC,wDAAwD,+CAAQ;AAChE,kDAAkD,+CAAQ;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,gDAAS;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,iEAAe;AACxC;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,gEAAU;AACtB;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,YAAY,gEAAU;AACtB;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,YAAY,0DAAmB,UAAU,qCAAqC;AAC9E,QAAQ,0DAAmB;AAC3B,QAAQ,0DAAmB,UAAU,kCAAkC;AACvE,YAAY,0DAAmB,aAAa,2EAA2E;AACvH,QAAQ,0DAAmB,WAAW,wDAAwD;AAC9F,YAAY,0DAAmB,UAAU,kCAAkC;AAC3E,gBAAgB,0DAAmB;AACnC,gBAAgB,0DAAmB,YAAY,mGAAmG;AAClJ,gBAAgB,0DAAmB;AACnC,YAAY,0DAAmB,UAAU,kCAAkC;AAC3E,gBAAgB,0DAAmB;AACnC,gBAAgB,0DAAmB,YAAY,mHAAmH;AAClK,gBAAgB,0DAAmB;AACnC,YAAY,0DAAmB,UAAU,kCAAkC;AAC3E,gBAAgB,0DAAmB;AACnC,gBAAgB,0DAAmB,YAAY,2IAA2I;AAC1L,gBAAgB,0DAAmB;AACnC,YAAY,0DAAmB,UAAU,kCAAkC;AAC3E,gBAAgB,0DAAmB;AACnC,gBAAgB,0DAAmB,YAAY,qIAAqI;AACpL,gBAAgB,0DAAmB;AACnC,YAAY,0DAAmB,UAAU,kCAAkC;AAC3E,gBAAgB,0DAAmB,aAAa,gEAAgE;AAChH,gBAAgB,0DAAmB,aAAa,8CAA8C;AAC9F;AACO,6BAA6B,6DAAW;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,0DAAmB,sBAAsB,uDAAuD;AAChH;AACA","sources":["webpack://jupyterlab_mutableai/./lib/connectors/connector.js","webpack://jupyterlab_mutableai/./lib/connectors/customConnector.js","webpack://jupyterlab_mutableai/./lib/handler.js","webpack://jupyterlab_mutableai/./lib/index.js","webpack://jupyterlab_mutableai/./lib/plugins/completer.js","webpack://jupyterlab_mutableai/./lib/plugins/contextMenu.js","webpack://jupyterlab_mutableai/./lib/plugins/settings.js","webpack://jupyterlab_mutableai/./lib/widgets/Settings.js"],"sourcesContent":["// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\n// Modified from jupyterlab/packages/completer/src/connector.ts\nimport { DataConnector } from '@jupyterlab/statedb';\n/**\n * A multi-connector connector for completion handlers.\n */\nexport class CompletionConnector extends DataConnector {\n    /**\n     * Create a new connector for completion requests.\n     *\n     * @param connectors - Connectors to request matches from, ordered by metadata preference (descending).\n     */\n    constructor(connectors) {\n        super();\n        this._connectors = connectors;\n    }\n    /**\n     * Fetch completion requests.\n     *\n     * @param request - The completion request text and details.\n     * @returns Completion reply\n     */\n    fetch(request) {\n        return Promise.all(this._connectors.map(connector => connector.fetch(request))).then(replies => {\n            const definedReplies = replies.filter((reply) => !!reply);\n            return Private.mergeReplies(definedReplies);\n        });\n    }\n}\n/**\n * A namespace for private functionality.\n */\nvar Private;\n(function (Private) {\n    /**\n     * Merge results from multiple connectors.\n     *\n     * @param replies - Array of completion results.\n     * @returns IReply with a superset of all matches.\n     */\n    function mergeReplies(replies) {\n        // Filter replies with matches.\n        const repliesWithMatches = replies.filter(rep => rep.matches.length > 0);\n        // If no replies contain matches, return an empty IReply.\n        if (repliesWithMatches.length === 0) {\n            return replies[0];\n        }\n        // If only one reply contains matches, return it.\n        if (repliesWithMatches.length === 1) {\n            return repliesWithMatches[0];\n        }\n        // Collect unique matches from all replies.\n        const matches = new Set();\n        repliesWithMatches.forEach(reply => {\n            reply.matches.forEach(match => matches.add(match));\n        });\n        // Note that the returned metadata field only contains items in the first member of repliesWithMatches.\n        return Object.assign(Object.assign({}, repliesWithMatches[0]), { matches: [...matches] });\n    }\n    Private.mergeReplies = mergeReplies;\n})(Private || (Private = {}));\n","/* eslint-disable @typescript-eslint/ban-ts-comment */\n// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\nimport { DataConnector } from '@jupyterlab/statedb';\nimport { requestAPI } from '../handler';\n/**\n * A custom connector for completion handlers.\n */\nexport class CustomConnector extends DataConnector {\n    /**\n     * Create a new custom connector for completion requests.\n     *\n     * @param options - The instatiation options for the custom connector.\n     */\n    constructor(options, panel, setting) {\n        super();\n        // @ts-ignore\n        this._editor = options.editor;\n        this._panel = panel;\n        this.setting = setting;\n    }\n    /**\n     * Fetch completion requests.\n     *\n     * @param request - The completion request text and details.\n     * @returns Completion reply\n     */\n    fetch(request) {\n        if (!this._editor) {\n            return Promise.reject('No editor');\n        }\n        return new Promise(resolve => {\n            const apiKey = this.setting.get('apiKey').composite;\n            const flag = this.setting.get('flag').composite;\n            const autocompleteDomain = this.setting.get('autocompleteDomain')\n                .composite;\n            resolve(Private.completionHint(\n            // @ts-ignore\n            this._editor, this._panel, autocompleteDomain, apiKey, flag));\n        });\n    }\n}\n/**\n * A namespace for Private functionality.\n */\nvar Private;\n(function (Private) {\n    /**\n     * Get a list of mocked completion hints.\n     *\n     * @param editor Editor\n     * @returns Completion reply\n     */\n    async function completionHint(editor, panel, domain, apiKey, flag) {\n        // Find the token at the cursor\n        const cursor = editor.getCursorPosition();\n        const token = editor.getTokenForPosition(cursor);\n        // get source of all cells\n        const cells = panel.content.widgets;\n        // get index of active cell\n        // @ts-ignore\n        const index = cells.indexOf(panel.content.activeCell);\n        // get all cells up to index\n        const cellsUpToIndex = cells.slice(0, index + 1);\n        // get all cells after index\n        const cellsAfterIndex = cells.slice(index + 1);\n        // append cellsUpToIndex to cellsAfterIndex\n        const cellsToComplete = cellsAfterIndex.concat(cellsUpToIndex);\n        // get source code of all cells\n        const sources = cellsToComplete.map(cell => cell.model.value.text);\n        // concatenate sources, this will be used as a prompt\n        const prompt = sources.join('\\n\\n');\n        console.log('prompt: ' + prompt);\n        // Get all text in the editor\n        //const activeCellText = editor.model.value.text;\n        // get token string\n        const tokenString = token.value;\n        // Send to handler\n        // TODO: rename this line to prompt\n        const dataToSend = { line: prompt, domain, apiKey, flag };\n        // POST request\n        let reply = requestAPI('AUTOCOMPLETE', {\n            body: JSON.stringify(dataToSend),\n            method: 'POST'\n        });\n        const response = await reply;\n        // Get size of text so that you can remove it from response\n        //const size = previousText.length;\n        //console.log(\"size of text: \" + size);\n        // Remove initial text in response\n        // const responseText = response.slice(size);\n        console.log('response: ' + response);\n        // Create a list of matching tokens.\n        const tokenList = [\n            { value: tokenString + response, offset: token.offset, type: 'AI' }\n            //{ value: token.value + 'Magic', offset: token.offset, type: 'magic' },\n            //{ value: token.value + 'Neither', offset: token.offset },\n        ];\n        //console.log(\"value and offset\")\n        //console.log(token.value)\n        //console.log(token.offset)\n        // Only choose the ones that have a non-empty type field, which are likely to be of interest.\n        const completionList = tokenList.filter(t => t.type).map(t => t.value);\n        // Remove duplicate completions from the list\n        const matches = Array.from(new Set(completionList));\n        return {\n            start: token.offset,\n            end: token.offset + token.value.length,\n            matches,\n            metadata: {}\n        };\n    }\n    Private.completionHint = completionHint;\n})(Private || (Private = {}));\n","import { URLExt } from '@jupyterlab/coreutils';\nimport { ServerConnection } from '@jupyterlab/services';\n/**\n * Call the API extension\n *\n * @param endPoint API REST end point for the extension\n * @param init Initial values for the request\n * @returns The response body interpreted as JSON\n */\nexport async function requestAPI(endPoint = '', init = {}) {\n    // Make request to Jupyter API\n    const settings = ServerConnection.makeSettings();\n    const requestUrl = URLExt.join(settings.baseUrl, 'jupyterlab-mutableai', // API Namespace\n    endPoint);\n    let response;\n    try {\n        response = await ServerConnection.makeRequest(requestUrl, init, settings);\n    }\n    catch (error) {\n        throw new ServerConnection.NetworkError(error);\n    }\n    let data = await response.text();\n    if (data.length > 0) {\n        try {\n            data = JSON.parse(data);\n        }\n        catch (error) {\n            console.log('Not a JSON response body.', response);\n        }\n    }\n    if (!response.ok) {\n        throw new ServerConnection.ResponseError(response, data.message || data);\n    }\n    return data;\n}\n","import contextMenu from './plugins/contextMenu';\nimport settings from './plugins/settings';\nimport completer from './plugins/completer';\n/**\n * Initialization data for the jupyterlab_mutableai extension.\n */\nconst plugins = [\n    contextMenu,\n    settings,\n    completer\n];\nexport default plugins;\n","import { ContextConnector, ICompletionManager, KernelConnector } from '@jupyterlab/completer';\nimport { ISettingRegistry } from '@jupyterlab/settingregistry';\nimport { INotebookTracker } from '@jupyterlab/notebook';\nimport { CompletionConnector } from '../connectors/connector';\nimport { CustomConnector } from '../connectors/customConnector';\n/**\n * The command IDs used by the console plugin.\n */\nvar CommandIDs;\n(function (CommandIDs) {\n    CommandIDs.invoke = 'completer:invoke';\n    CommandIDs.invokeNotebook = 'completer:invoke-notebook-1';\n    CommandIDs.select = 'completer:select';\n    CommandIDs.selectNotebook = 'completer:select-notebook-custom';\n})(CommandIDs || (CommandIDs = {}));\nconst SETTINGS_PLUGIN_ID = 'jupyterlab_mutableai:settings-mutableai';\n/**\n * Initialization data for the extension.\n */\nconst completer = {\n    id: 'completer',\n    autoStart: true,\n    requires: [ICompletionManager, INotebookTracker, ISettingRegistry],\n    activate: async (app, completionManager, notebooks, settings) => {\n        console.log('Mutable AI custom completer extension is activated!');\n        Promise.all([app.restored, settings.load(SETTINGS_PLUGIN_ID)]).then(([, setting]) => {\n            // Modelled after completer-extension's notebooks plugin\n            const enabled = setting.get('enabled').composite;\n            if (enabled) {\n                notebooks.widgetAdded.connect((sender, panel) => {\n                    var _a, _b;\n                    let editor = (_b = (_a = panel.content.activeCell) === null || _a === void 0 ? void 0 : _a.editor) !== null && _b !== void 0 ? _b : null;\n                    const session = panel.sessionContext.session;\n                    const options = { session, editor };\n                    const connector = new CompletionConnector([]);\n                    const handler = completionManager.register({\n                        connector,\n                        editor,\n                        parent: panel\n                    });\n                    const updateConnector = () => {\n                        var _a, _b;\n                        editor = (_b = (_a = panel.content.activeCell) === null || _a === void 0 ? void 0 : _a.editor) !== null && _b !== void 0 ? _b : null;\n                        options.session = panel.sessionContext.session;\n                        options.editor = editor;\n                        handler.editor = editor;\n                        const kernel = new KernelConnector(options);\n                        const context = new ContextConnector(options);\n                        /*\n                         * The custom connector is getting initialized with settings.\n                         * This is used to get the updated settings while making the\n                         * completer api call.\n                         */\n                        const custom = new CustomConnector(options, panel, setting);\n                        handler.connector = new CompletionConnector([\n                            custom,\n                            kernel,\n                            context\n                        ]);\n                    };\n                    // Update the handler whenever the prompt or session changes\n                    panel.content.activeCellChanged.connect(updateConnector);\n                    panel.sessionContext.sessionChanged.connect(updateConnector);\n                });\n                // Add notebook completer command.\n                app.commands.addCommand(CommandIDs.invokeNotebook, {\n                    execute: () => {\n                        var _a;\n                        const panel = notebooks.currentWidget;\n                        if (panel && ((_a = panel.content.activeCell) === null || _a === void 0 ? void 0 : _a.model.type) === 'code') {\n                            return app.commands.execute(CommandIDs.invoke, {\n                                id: panel.id\n                            });\n                        }\n                    }\n                });\n                // Add notebook completer select command.\n                app.commands.addCommand(CommandIDs.selectNotebook, {\n                    execute: () => {\n                        const id = notebooks.currentWidget && notebooks.currentWidget.id;\n                        if (id) {\n                            return app.commands.execute(CommandIDs.select, { id });\n                        }\n                    }\n                });\n                // Set enter key for notebook completer select command.\n                app.commands.addKeyBinding({\n                    command: CommandIDs.selectNotebook,\n                    keys: ['Enter'],\n                    selector: '.jp-Notebook .jp-mod-completer-active'\n                });\n            }\n        });\n    }\n};\nexport default completer;\n","import { ISettingRegistry } from '@jupyterlab/settingregistry';\nimport { IFileBrowserFactory } from '@jupyterlab/filebrowser';\nimport { fastForwardIcon } from '@jupyterlab/ui-components';\nimport { MainAreaWidget } from '@jupyterlab/apputils';\nimport { settingsIcon } from '@jupyterlab/ui-components';\nimport { SettingsWidget } from '../widgets/Settings';\nimport { IMainMenu, MainMenu } from '@jupyterlab/mainmenu';\nimport { ITranslator } from '@jupyterlab/translation';\nimport { requestAPI } from '../handler';\nconst COMMAND_ID = 'jupyterlab_mutableai/settings:toggle-flag';\nconst COMMAND_SETTINGS_ID = 'jupyterlab_mutableai/settings:update-settings';\n/**\n * Initialization data for the jupyterlab_mutableai extension.\n */\nconst SETTINGS_PLUGIN_ID = 'jupyterlab_mutableai:settings-mutableai';\n// class MenuRenderer extends Menu.Renderer {\n//   renderItem(data: Menu.IRenderData): VirtualElement {\n//     // data = {\n//     //   ...data,\n//     //   item: {\n//     //     ...data.item,\n//     //     label: 'MutableAI Settings'\n//     //   }\n//     // };\n//     console.log('this is called..', data);\n//     let className = this.createItemClass(data);\n//     let dataset = this.createItemDataset(data);\n//     let aria = this.createItemARIA(data);\n//     return h.li(\n//       {\n//         className,\n//         dataset,\n//         tabindex: '0',\n//         onfocus: data.onfocus,\n//         ...aria\n//       },\n//       this.renderIcon(data),\n//       this.renderLabel(data),\n//       this.renderShortcut(data),\n//       this.renderSubmenu(data)\n//     );\n//   }\n// }\nconst contextMenu = {\n    id: 'jupyterlab_mutableai:contextMenu',\n    autoStart: true,\n    requires: [IFileBrowserFactory, ISettingRegistry, IMainMenu, ITranslator],\n    activate: (app, factory, settings, mainMenu, translator) => {\n        console.log('Mutable AI context menu is activated!');\n        let flag = true;\n        const trans = translator.load('jupyterlab');\n        /**\n         * Load the settings for this extension\n         *\n         * @param setting Extension settings\n         */\n        function loadSetting(setting) {\n            // Read the settings and convert to the correct type\n            flag = setting.get('flag').composite;\n        }\n        const command = 'context_menu:open';\n        // Wait for the application to be restored and\n        // for the settings for this plugin to be loaded\n        Promise.all([app.restored, settings.load(SETTINGS_PLUGIN_ID)]).then(([, setting]) => {\n            // Read the settings\n            loadSetting(setting);\n            const enabled = setting.get('enabled').composite;\n            if (enabled) {\n                const { commands } = app;\n                const mutableAiMainMenu = MainMenu.generateMenu(commands, {\n                    id: 'mutable-ai-settings',\n                    label: 'Mutable AI Settings',\n                    rank: 80\n                }, trans);\n                mutableAiMainMenu.addGroup([\n                    {\n                        command: COMMAND_ID\n                    },\n                    {\n                        command: COMMAND_SETTINGS_ID\n                    }\n                ]);\n                mainMenu.addMenu(mutableAiMainMenu, { rank: 80 });\n                // Listen for your plugin setting changes using Signal\n                setting.changed.connect(loadSetting);\n                commands.addCommand(COMMAND_ID, {\n                    label: 'AutoComplete',\n                    isToggled: () => flag,\n                    execute: () => {\n                        // Programmatically change a setting\n                        Promise.all([setting.set('flag', !flag)])\n                            .then(() => {\n                            const newFlag = setting.get('flag').composite;\n                            console.log(`Mutable AI updated flag to '${newFlag ? 'enabled' : 'disabled'}'.`);\n                        })\n                            .catch(reason => {\n                            console.error(`Something went wrong when changing the settings.\\n${reason}`);\n                        });\n                    }\n                });\n                commands.addCommand(COMMAND_SETTINGS_ID, {\n                    label: 'Update Mutable AI Settings',\n                    execute: () => {\n                        const close = () => { var _a; return (_a = app.shell.currentWidget) === null || _a === void 0 ? void 0 : _a.close(); };\n                        const content = new SettingsWidget(setting, close);\n                        const widget = new MainAreaWidget({ content });\n                        widget.title.label = 'MutableAI Settings';\n                        widget.title.icon = settingsIcon;\n                        app.shell.add(widget, 'main');\n                    }\n                });\n                commands.addCommand(command, {\n                    label: 'Fast Forward to Production with MutableAI',\n                    caption: 'Mutable AI context menu.',\n                    icon: fastForwardIcon,\n                    execute: () => {\n                        var _a;\n                        const file = (_a = factory.tracker.currentWidget) === null || _a === void 0 ? void 0 : _a.selectedItems().next();\n                        const apiKey = setting.get('apiKey').composite;\n                        const transformDomain = setting.get('transformDomain')\n                            .composite;\n                        const dataToSend = { name: file === null || file === void 0 ? void 0 : file.path, apiKey, transformDomain };\n                        // POST request\n                        const reply = requestAPI('TRANSFORM_NB', {\n                            body: JSON.stringify(dataToSend),\n                            method: 'POST'\n                        });\n                        // Log to console\n                        reply\n                            .then(response => console.log('Transformed Successfully!'))\n                            .catch(e => console.log('Transformation failed!', e));\n                    }\n                });\n            }\n        });\n    }\n};\nexport default contextMenu;\n","import { ISettingRegistry } from '@jupyterlab/settingregistry';\nconst PLUGIN_ID = 'jupyterlab_mutableai:settings-mutableai';\n/**\n * Initialization data for the settings extension.\n */\nconst settings = {\n    id: PLUGIN_ID,\n    autoStart: true,\n    requires: [ISettingRegistry],\n    activate: (app, settings) => { }\n};\nexport default settings;\n","import { ReactWidget } from '@jupyterlab/apputils';\nimport { showDialog, Dialog } from '@jupyterlab/apputils';\nimport React, { useState, useEffect } from 'react';\nconst SettingsComponent = (props) => {\n    const { setting, close } = props;\n    const [autoCompleteFlag, setAutoCompleteFlag] = useState(false);\n    const [apiKey, setApiKey] = useState('');\n    const [autocompleteDomain, setAutocompleteDomain] = useState('');\n    const [transformDomain, setTransformDomain] = useState('');\n    const setValues = () => {\n        // Read the settings and convert to the correct type\n        setAutoCompleteFlag(setting.get('flag').composite);\n        setApiKey(setting.get('apiKey').composite);\n        setAutocompleteDomain(setting.get('autocompleteDomain').composite);\n        setTransformDomain(setting.get('transformDomain').composite);\n    };\n    const restoreToDefault = () => {\n        /*\n         * This fetches the default settings from\n         * user settings then sets then sets it\n         * in the form. But as the form is not\n         * submitted it is not saved until save\n         * button is pressed.\n         */\n        const flagDefault = setting.default('flag');\n        const apiKeyDefault = setting.default('apiKey');\n        const autocompleteDomainDefault = setting.default('autocompleteDomain');\n        const transformDomainDefault = setting.default('transformDomain');\n        setAutoCompleteFlag(flagDefault);\n        setApiKey(apiKeyDefault);\n        setAutocompleteDomain(autocompleteDomainDefault);\n        setTransformDomain(transformDomainDefault);\n        setting.set('flag', flagDefault);\n        setting.set('apiKey', apiKeyDefault);\n        setting.set('autocompleteDomain', autocompleteDomainDefault);\n        setting.set('transformDomain', transformDomainDefault);\n    };\n    /*\n     * Whenever the settings object is changed from\n     * outside the widget it updates the form accordingly.\n     */\n    setting.changed.connect(setValues);\n    useEffect(() => {\n        /*\n         * When the widget is attached.\n         * It gets the last values from\n         * settings object and updates the\n         * settings form.\n         */\n        setValues();\n    }, []);\n    const handleSubmit = (e) => {\n        /*\n         * This function gets the submitted form\n         * It then updates the values from form-data\n         * After that the latest data is saved in user-settings.\n         * Also after successful saving it shows a\n         */\n        e.preventDefault();\n        const okButton = Dialog.okButton({\n            className: 'btn jp-mutableai-modal-btn'\n        });\n        try {\n            setting.set('flag', autoCompleteFlag);\n            setting.set('apiKey', apiKey);\n            setting.set('autocompleteDomain', autocompleteDomain);\n            setting.set('transformDomain', transformDomain);\n            // Success dialog.\n            showDialog({\n                title: 'Mutable AI Settings',\n                body: 'The changes saved successfully!',\n                buttons: [okButton]\n            });\n        }\n        catch (e) {\n            // Error dialog.\n            showDialog({\n                title: 'Mutable AI Settings',\n                body: 'Something went wrong saving settings. Reason: ' + e.toString(),\n                buttons: [okButton]\n            });\n        }\n    };\n    return (React.createElement(\"div\", { className: \"jp-mutableai-container\" },\n        React.createElement(\"h1\", null, \"Mutable AI Settings\"),\n        React.createElement(\"div\", { className: \"jp-mutableai-header\" },\n            React.createElement(\"button\", { className: \"btn btn-secondary\", type: \"button\", onClick: restoreToDefault }, \"Restore to Defaults\")),\n        React.createElement(\"form\", { className: \"jp-mutableai-form\", onSubmit: handleSubmit },\n            React.createElement(\"div\", { className: \"jp-mutableai-group \" },\n                React.createElement(\"label\", null, \"Autocomplete Flag\"),\n                React.createElement(\"input\", { type: \"checkbox\", checked: autoCompleteFlag, onChange: e => setAutoCompleteFlag(e.target.checked) }),\n                React.createElement(\"span\", null, \"This controls whether or not autocomplete is activated.\")),\n            React.createElement(\"div\", { className: \"jp-mutableai-group \" },\n                React.createElement(\"label\", null, \"API key\"),\n                React.createElement(\"input\", { className: \"form-control\", placeholder: \"\", type: \"text\", value: apiKey, onChange: e => setApiKey(e.target.value) }),\n                React.createElement(\"span\", null, \"This is the api key to call the endpoints.\")),\n            React.createElement(\"div\", { className: \"jp-mutableai-group \" },\n                React.createElement(\"label\", null, \"Autocomplete Domain\"),\n                React.createElement(\"input\", { className: \"form-control\", placeholder: \"\", type: \"text\", value: autocompleteDomain, onChange: e => setAutocompleteDomain(e.target.value) }),\n                React.createElement(\"span\", null, \"Used to construct url to call autocomplete endpoint\")),\n            React.createElement(\"div\", { className: \"jp-mutableai-group \" },\n                React.createElement(\"label\", null, \"Transform Domain\"),\n                React.createElement(\"input\", { className: \"form-control\", placeholder: \"\", type: \"text\", value: transformDomain, onChange: e => setTransformDomain(e.target.value) }),\n                React.createElement(\"span\", null, \"Used to construct url to call transform endpoint\")),\n            React.createElement(\"div\", { className: \"jp-mutableai-footer\" },\n                React.createElement(\"button\", { className: \"btn btn-secondary\", type: \"button\", onClick: close }, \"Cancel\"),\n                React.createElement(\"button\", { className: \"btn btn-success\", type: \"submit\" }, \"Save\")))));\n};\nexport class SettingsWidget extends ReactWidget {\n    constructor(setting, close) {\n        super();\n        // This is the top widget class for settings widget.\n        this.addClass('jp-mutableai-widget');\n        // settings object passed here is used.\n        // This is used to get, set, update\n        // mutable AI settings.\n        this.setting = setting;\n        // This is used to close the shell.\n        this.closeShell = close;\n    }\n    render() {\n        // This is the settings component passed to the widget.\n        return (React.createElement(SettingsComponent, { setting: this.setting, close: () => this.closeShell() }));\n    }\n}\n"],"names":[],"sourceRoot":""}