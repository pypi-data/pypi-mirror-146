#
#    Copyright 2022 Embedded Systems Unit, Fondazione Bruno Kessler
#
#    Licensed under the Apache License, Version 2.0 (the "License");
#    you may not use this file except in compliance with the License.
#    You may obtain a copy of the License at
#
#        http://www.apache.org/licenses/LICENSE-2.0
#
#    Unless required by applicable law or agreed to in writing, software
#    distributed under the License is distributed on an "AS IS" BASIS,
#    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#    See the License for the specific language governing permissions and
#    limitations under the License.
#
'''Module exporting classes to define traces.

Traces can be generated by solvers, for example to define a counterexample.
'''

from pyvmt import exceptions
from pyvmt.environment import get_env
from pysmt.smtlib.script import SmtLibCommand
from pysmt.smtlib.commands import DEFINE_FUN

class TraceStep:
    '''Represents a single step within the trace
    holds a set of assignments from variables within the environment
    to constant values. This class should be used together with
    pyvmt.solvers.traces.Trace
    '''
    def __init__(self, assignments, is_loopback=False, step_idx=None, trace=None):
        self._assignments = assignments
        self._trace = trace
        self.is_loopback = is_loopback
        self.step_idx = step_idx

    def get_assignment(self, variable):
        '''Gets the assignment of a variable in this step

        :param variable: The variable
        :type variable: pysmt.fnode.FNode
        :return: The current value of the variable
        :rtype: pysmt.fnode.FNode
        '''
        return self._assignments[variable]

    def get_assignments(self):
        '''Gets a copy of the assignments

        :return: The assignments within this step
        :rtype: Dict[pysmt.fnode.FNode, pysmt.fnode.FNode]
        '''
        return self._assignments.copy()

    def get_formula(self):
        '''Generates a formula to represent the full step

        :return: The And of all the assignments
        :rtype: pysmt.fnode.FNode
        '''
        env = self._trace.get_env()
        mgr = env.formula_manager
        atoms = []
        for variable, value in self._assignments.items():
            if value.is_true():
                atoms.append(variable)
            elif value.is_false():
                atoms.append(mgr.Not(variable))
            else:
                atoms.append(mgr.Equals(variable, value))
        return mgr.And(atoms)

    def get_command(self, fname=None):
        '''Generates an SMT-LIB command to represent the step

        :param fname: The name of the function for the command, defaults to None
        :type fname: str, optional
        :return: A command containing the formula for the step
        :rtype: pysmt.smtlib.script.SmtLibFunction
        '''
        if fname is None:
            fname = f'step-{self.step_idx}'
            if self.is_loopback:
                fname = f'loopback-{fname}'
        formula = self.get_formula()
        command = SmtLibCommand(DEFINE_FUN, [fname, [], formula.get_type(), formula])
        return command

    def serialize(self, outstream, fname=None, daggify=False):
        '''Serialize the step as an SMT-LIB command

        :param outstream: The stream to write to
        :param fname: The name of the function for the command, defaults to None
        :type fname: str, optional
        :param daggify: Whether to daggify the output, defaults to False
        :type daggify: bool, optional
        '''
        command = self.get_command(fname=fname)
        command.serialize(outstream, daggify)

    def serialize_to_string(self, daggify=False):
        '''Serialize the step as an SMT-LIB command to a string

        :param daggify: Whether to daggify the output, defaults to False
        :type daggify: bool, optional
        :return: The result of serializing the step
        :rtype: str
        '''
        command = self.get_command()
        return command.serialize_to_string(daggify)

    def get_next_step(self):
        '''Get the step after this one, if the current step is the
        final one in the trace returns the loopback step, if no loopback is available
        raises an exception.

        :return: The next step
        :rtype: pyvmt.solvers.traces.TraceStep
        '''
        if self.step_idx + 1 < self._trace.steps_count():
            return self._trace.get_step(self.step_idx + 1)
        if self._trace.has_loopback_step():
            return self._trace.get_loopback_step()
        raise exceptions.TraceStepNotFoundError(
            "Step is the final one in the trace and no loopback is available")

    def get_prev_step(self):
        '''Get the step before this one, if the current step is the
        first one in the trace raises an exception.

        Note: this function ignores whether the step is a loopback step.

        :return: The prev step
        :rtype: pyvmt.solvers.traces.TraceStep
        '''
        # TODO should the behaviour for the first step check if it's a
        # loopback step (and return the last step)?
        if self.step_idx - 1 >= 0:
            return self._trace.get_step(self.step_idx - 1)
        raise exceptions.TraceStepNotFoundError(
            "Step is the first one in the trace")

    def has_next_step(self):
        '''Returns whether this step has a next step in the trace, if a loopback step is available
        this will always be the case.

        :return: True if the trace has a step after this one, False otherwise
        :rtype: bool
        '''
        try:
            _ = self.get_next_step()
            return True
        except exceptions.TraceStepNotFoundError:
            return False

    def has_prev_step(self):
        '''Returns whether this step has a prev step in the trace.

        Note: this function ignores whether the step is a loopback step.

        :return: True if the trace has a step before this one, False otherwise.
            Also returns False if this is the first step in the trace, even if it's
            a loopback step.
        :rtype: bool
        '''
        try:
            _ = self.get_prev_step()
            return True
        except exceptions.TraceStepNotFoundError:
            return False

    def evaluate_formula(self, formula):
        '''Evaluate a formula for the current trace step. If the Next operator is present
        in the formula, next state variables will be replaced with their value in the next step
        if a next step is available.

        If the formula resulting from the value substitution can be simplified completely,
        returns an FNode containing a constant value.

        :param formula: The formula to evaluate
        :type formula: pysmt.fnode.FNode
        :return: The result from the evaluation of the formula
        :rtype: pysmt.fnode.FNode
        '''
        env = self._trace.get_env()
        mgr = env.formula_manager
        simplifier = env.simplifier
        substituter = env.substituter
        pusher = env.next_pusher
        next_op_walker = env.has_next_operator_walker
        subs = self._assignments.copy()
        if self.has_next_step():
            # combine the current assignments with the next assignments
            next_step = self.get_next_step()
            for state_var in self._trace.get_state_vars():
                subs[mgr.Next(state_var)] = next_step.get_assignment(state_var)

        # push all of the Next operators to the leaves
        formula = pusher.push_next(formula)

        # substitute the variables with the values of the trace
        formula = substituter.substitute(formula, subs=subs)

        # If there are still Next operators remaining in the formula, there's
        # either no next step to perform the replacements or a Next operator
        # is on a variable which could not be replaced, for example a bound variable
        if next_op_walker.has_next(formula):
            raise exceptions.UnexpectedNextError(
                "After substituting all the variable values Next operators are still present")

        # simplify the formula and return the result
        formula = simplifier.simplify(formula)
        return formula

    def get_changed_variables(self):
        '''Get the set of changed variables between this step and the previous one.

        If this is the first step returns all of the variables since they were all initialized.

        :return: A set containing the changed variables between this step and the previous one
        :rtype: Set[pysmt.fnode.FNode]
        '''
        if self.step_idx == 0:
            return set(self.get_assignments())
        return self.get_different_variables(self.get_prev_step())

    def get_changing_variables(self):
        '''Get the set of changing variables between this step and the next one.

        :return: A set containing the changed variables between this step and the next one
        :rtype: Set[pysmt.fnode.FNode]
        '''
        next_step = self.get_next_step()
        return self.get_different_variables(next_step)

    def get_different_variables(self, other):
        '''Get the variables in this step that are different from the variables
        in the step passed as input.

        :param other: The step to compare to
        :type other: pyvmt.solvers.traces.TraceStep
        :return: The variables in this step that are different from the variables in the other step
        :rtype: Set[pysmt.fnode.FNode]
        '''
        assignment_2 = other.get_assignments()
        different = set()
        for key, value in self._assignments.items():
            if key in assignment_2 and assignment_2[key] != value:
                different.add(key)
        return different

class Trace:
    '''Represents an execution trace, can be generated by a solver
    as a counterexample to an invariant property
    '''

    def __init__(self, trace_type, state_vars, env=None):
        self._steps = []
        self._loopback_step_idx = None
        self._trace_type = trace_type
        self._state_vars = frozenset(state_vars)
        if env is None:
            env = get_env()
        self._env = env

    def get_env(self):
        '''Retrieve the environment for the trace

        :return: The environment of the trace
        :rtype: pyvmt.environment.Environment
        '''
        return self._env

    def get_state_vars(self):
        '''Retrieve the state variables that the trace contains

        :return: A frozenset containing the trace state variables
        :rtype: frozenset[pysmt.fnode.FNode]
        '''
        return self._state_vars

    def add_step(self, step):
        '''Add a trace step to the trace

        :param step: The step to add
        :type step: pyvmt.solvers.traces.TraceStep
        '''
        self._steps.append(step)
        if step.is_loopback:
            if self._loopback_step_idx is not None:
                raise exceptions.DuplicateLoopbackStepError(
                    "This trace already has a loopback step assigned")
            self._loopback_step_idx = step.step_idx

    def create_step(self, assignments, is_loopback=False):
        '''Creates a step from the assignments and whether the created step
        should be a loopback step, assigns the step idx and the trace to the step.

        :param assignments: The assignments for the step
        :type assignments: Dict[pysmt.fnode.FNode, pysmt.fnode.FNode]
        :param is_loopback: Whether the step is a loopback step, defaults to False
        :type is_loopback: bool, optional
        '''
        step = TraceStep(assignments,
            is_loopback=is_loopback,
            step_idx=len(self._steps),
            trace=self)
        self.add_step(step)
        return step

    def get_step(self, idx):
        '''Retrieve a step from the step index

        :param idx: The step index
        :type idx: int
        :return: The corresponding step
        :rtype: pyvmt.solvers.traces.TraceStep
        '''
        try:
            return self._steps[idx]
        except IndexError as err:
            raise exceptions.TraceStepNotFoundError(
                f"Trace step with idx {idx} not found") from err

    def get_steps(self):
        '''Get a copy of the list of steps in the trace

        :return: The list of steps
        :rtype: List[pyvmt.solvers.traces.TraceStep]
        '''
        return self._steps.copy()

    def get_loopback_step_idx(self):
        '''Get the index of the loopback step, the loopback
        step must already be assigned

        :return: The index of the loopback step
        :rtype: int
        '''
        if not self.has_loopback_step():
            raise exceptions.MissingLoopbackStepError(
                "This trace does not have a loopback step assigned")
        return self._loopback_step_idx

    def get_loopback_step(self):
        '''Get the loopback step, the loopback step
        step must already be asigned

        :return: The loopback step
        :rtype: pyvmt.solvers.traces.TraceStep
        '''
        return self._steps[self.get_loopback_step_idx()]

    def has_loopback_step(self):
        '''Returns whether the trace has a loopback step.

        :return: True if the trace has a loopback step, False otherwise
        :rtype: bool
        '''
        return self._loopback_step_idx is not None

    def get_trace_type(self):
        '''Get the trace type

        :return: The type of the trace
        :rtype: str
        '''
        return self._trace_type

    def steps_count(self):
        '''Returns the count of steps within the trace.

        :return: The count of steps within the trace
        :rtype: int
        '''
        return len(self._steps)
