# AUTOGENERATED! DO NOT EDIT! File to edit: nbs/encryption.ipynb (unless otherwise specified).

__all__ = ['get_encryption_phrase', 'generate_custom_key', 'generate_devtransfer_encryption_key', 'load_fernet',
           'encrypt_file', 'decencrypt_file']

# Cell
from pathlib import Path
import tempfile
from rich import print
from rich.prompt import Prompt
import base64
from cryptography.fernet import Fernet
import os
import shutil

def get_encryption_phrase(count=0):
    if count > 5:
        raise Exception(f"Creating a encryption phrase failed too many times. Please try again.")
    encryption_key = Prompt.ask("Enter a one-time encryption phrase [gray](typing hidden)", password=True)
    encryption_key2 = Prompt.ask("Verify phrase", password=True)
    if encryption_key != encryption_key2:
        print("[bold red]Verification failed. Please try again.\n ")
        return get_encryption_phrase(count=count +1)
    return encryption_key2

# Cell

def generate_custom_key():
    """
    This is an example of how you can create your own encryption key.
    Use it at your own risk.

    It works exactly like:
    ```
    import base64
    import os

    key = base64.urlsafe_b64encode(os.urandom(32)).decode()
    print(key)
    ```
    """
    return base64.urlsafe_b64encode(os.urandom(32)).decode()

# Cell
def generate_devtransfer_encryption_key(as_str=True):
    """
    This is the recommended implementation using
    the python `cryptography` package.

    :as_str is a flag that's recommended for moving the resulting key around.
    """
    if not as_str:
        return Fernet.generate_key()
    return Fernet.generate_key().decode("UTF-8")

# Cell

def load_fernet(key:str):
    fernet = None
    try:
        fernet = Fernet(key)
    except:
        raise Exception("There was a problem with your encryption key.")
    return fernet

# Cell
def encrypt_file(source_path:Path, key:str, tmp_dirname:Path = None) -> Path:
      """
      :source_path -> input file path
      :key -> encryption key generated from any of:
         - `devtransfer.encryption.generate_custom_key`
         - `devtransfer.encryption.generate_devtransfer_encryption_key`
         - `Fernet.generate_key()`
      """
      if source_path.is_dir():
         raise Exception("You cannot encrypt a directory.\nThe following must be a file:\n\t-{source_path}")
      _path = source_path.resolve()
      if not _path.exists():
         raise Exception(f"{source_path} not found.")
      fernet = load_fernet(key)
      if tmp_dirname is None:
         tmp_dirname = tempfile.mkdtemp()
      outpath_name = f"_{source_path.stem}-encrypted{source_path.suffix}"
      encrypted_data = fernet.encrypt(_path.read_bytes())
      outpath = Path(tmp_dirname)/ outpath_name
      outpath.write_bytes(encrypted_data)
      return outpath


# Cell
def decencrypt_file(source_path:Path, output_path:Path, key:str, overwrite=False) -> Path:
      """
      :source_path -> input file path
      :key -> encryption key generated from any of:
         - `devtransfer.encryption.generate_custom_key`
         - `devtransfer.encryption.generate_devtransfer_encryption_key`
         - `Fernet.generate_key()`
      """
      if source_path.is_dir() or output_path.is_dir():
         raise Exception("You cannot decrypt a directory.\nThe following must both be files:\n\t-{source_path}\n\t-{output_path}")
      _path = source_path.resolve()
      if not _path.exists():
         raise Exception(f"{source_path} not found.")
      fernet = load_fernet(key)
      decrypted_data = fernet.decrypt(source_path.read_bytes())
      if output_path.exists() and overwrite is False:
         raise Exception(f"{output_path} already exists, pass `--overwrite` to continue.")
      output_path.write_bytes(decrypted_data)
      return output_path