# AUTOGENERATED! DO NOT EDIT! File to edit: nbs/downloader.ipynb (unless otherwise specified).

__all__ = ['BASE_ENDPOINT', 'PROXY_ENDPOINT', 'USER_HOME', 'verify_endpoint', 'prepare_url', 'tap_endpoint_metadata',
           'get_download_path', 'download_via_id', 'download_via_url']

# Cell
import requests
import json
import pathlib
import urllib.parse as urlparse
from urllib.parse import urlencode

from rich import print
from rich.console import Console
from rich.progress import Progress, SpinnerColumn, TimeElapsedColumn
from devtransfer import conf, exceptions, http, utils

BASE_ENDPOINT = conf.BASE_ENDPOINT
PROXY_ENDPOINT = conf.PROXY_ENDPOINT
USER_HOME=conf.USER_HOME

# Cell

def verify_endpoint(url):
    parsed = urlparse.urlparse(url)
    if parsed.netloc != "f.devtransfer.com":
        raise exceptions.InvalidDownloadURLException("URL invalid, please try again.")
    return

def prepare_url(url):
    parsed = urlparse.urlparse(url)
    parsed_data = list(parsed)
    query = dict(urlparse.parse_qsl(parsed_data[4]))
    query.update({"details-only": "true"})
    parsed_data[4] = urlencode(query)
    return urlparse.urlunparse(parsed_data)

def tap_endpoint_metadata(url, return_response=False):
    verify_endpoint(url)
    _url = prepare_url(url)
    r = http.requests.get(_url)
    if return_response:
        return r
    if r.status_code not in range(200, 299):
        return {}
    return r.json()

def get_download_path(outpath=None, fname="download", overwrite=False):
    if str(outpath).startswith("~/") or str(outpath).startswith("~\\"):
        outpath = pathlib.Path().home() / outpath[2:]
    if not isinstance(outpath, pathlib.Path):
        try:
            outpath = pathlib.Path(outpath).resolve()
        except:
            outpath = None
        if outpath is None:
            outpath = USER_HOME / "Downloads" / fname
    if outpath.is_dir():
        outpath = outpath / fname
    if outpath.is_file():
        outpath = outpath
    if outpath.exists() and overwrite == False:
        rand_str = utils.get_random_string(size=4)
        outpath = outpath.parent / f"{outpath.stem}-{rand_str}{outpath.suffix}"
        return get_download_path(outpath=outpath, fname=fname, overwrite=overwrite)
    if outpath.exists() and overwrite == True:
        pass
    return outpath

def download_via_id(id=None, path=None, overwrite=False,):
    url = f"{PROXY_ENDPOINT}/{id}"
    r = tap_endpoint_metadata(url, return_response=True)
    if r.status_code not in range(200, 299):
        print("Invalid request. {slug} is invalid. \nPlease try again.")
        return
    metadata = r.json()
    return download_via_url(url, path=path, overwrite=overwrite, metadata=metadata )

def download_via_url(url, path=None, overwrite=False, metadata=None):
    if metadata is None:
        metadata = tap_endpoint_metadata(url)
    _url = metadata.get("url")
    fname = metadata.get('filename')
    try:
        fsize = int(metadata.get('file_size'))
    except:
        fsize = None
    display_fsize = "~"
    chunk_size = 8192
    total_size = chunk_size * 10
    if isinstance(fsize, int):
        display_fsize = utils.human_size(fsize)
        total_size = fsize
    download_path = get_download_path(outpath=path, fname=fname, overwrite=overwrite)
    print(f"[green]Downloading {fname} ({display_fsize}) to:\n\n{download_path}")
    console = Console(record=True)
    with Progress(SpinnerColumn(),
        *Progress.get_default_columns(),
        TimeElapsedColumn(),
        console=console,
        transient=True,) as progress:
        task1 = progress.add_task(f"[blue][green]Downloading {fname} ({display_fsize})", total=total_size, start=False)
        with requests.get(_url, stream=True) as r:
            r.raise_for_status()
            progress.start_task(task1)
            completed = 0
            with open(download_path, 'wb') as f:
                for chunk in r.iter_content(chunk_size=chunk_size):
                    f.write(chunk)
                    completed += chunk_size
                    progress.update(task1, advance=chunk_size, description = f"[green]Finished ({utils.human_size(completed)} of {display_fsize})...")
        progress.update(task1, completed=True, description = f"[bold green]Success ({completed} of {display_fsize})...")
    return download_path