# AUTOGENERATED! DO NOT EDIT! File to edit: nbs/compression.ipynb (unless otherwise specified).

__all__ = ['zip_file_paths']

# Cell
import os
import pathlib
import shutil
import tempfile
import zipfile

from rich.progress import Progress, BarColumn, TimeElapsedColumn
from devtransfer import exceptions, formatting, utils




def zip_file_paths(name="compressed",
        root_dir=".",
        files=[],
        destination_dir=None,
        ignore_filename=".gitignore",
        tmp_dirname=None,
        verbose=0):
    root_dir_path = utils.resolve_path(root_dir)
    compressing_dir = root_dir_path.is_dir()
    gitignore_path = root_dir_path / ignore_filename
    if compressing_dir and not gitignore_path.exists():
        raise exceptions.GitignoreNotPresentException(f"You must have a `.gitignore` or `.devignore` in the root of {root_dir_path}.")
    if tmp_dirname is None:
         tmp_dirname = tempfile.mkdtemp()
    z_path = pathlib.Path(tmp_dirname) / f"{name}.zip"
    with Progress("[progress.description]{task.description}",
                BarColumn(),
                "[progress.percentage]{task.percentage:>3.0f}%",
                TimeElapsedColumn()) as progress:
        task = progress.add_task(f"{root_dir_path.name}/", total=len(files))
        with zipfile.ZipFile(z_path, 'w') as zipObj:
            for f_path_str in files:
                progress.update(task, advance=1)
                f_path = utils.resolve_path(f_path_str)
                if f_path.is_file():
                    if compressing_dir:
                        should_skip = utils.should_ignore_file(f_path, gitignore_path)
                        if should_skip:
                            continue
                    valid_file_size = utils.verify_file_size(f_path)
                    if not valid_file_size:
                        file_size = utils.file_size_display(f_path)
                        progress.console.print(f"[red]:x: {f_path_str} ({file_size} is too large)")
                        continue
                    progress.console.print(f"[green]{f_path_str}")
                    zipObj.write(f_path, f_path.name)
                if f_path.is_dir():
                    files_length = len(list(f_path.glob("*")))
                    task2 = progress.add_task(f"{root_dir_path.name}/{f_path.relative_to(root_dir_path)}/", total=files_length, style="#e7f2fa")
                    progress.console.print(f"[green]{f_path}/")
                    # Iterate over all the files in directory
                    for folderName, _, filenames in os.walk(f_path):
                        for filename in filenames:
                            progress.update(task2, advance=1)
                            #create complete filepath of file in directory
                            _zip_filepath = pathlib.Path(os.path.join(folderName, filename))
                            _rel_filepath = _zip_filepath.relative_to(root_dir_path)

                            should_skip = utils.should_ignore_file(_zip_filepath, gitignore_path)
                            if should_skip:
                                if verbose == formatting.Verbosity.DETAIL:
                                    print(f"Ignoring {_rel_filepath}.")
                                continue
                            valid_file_size = utils.verify_file_size(f_path)
                            if not valid_file_size:
                                file_size = utils.file_size_display(f_path)
                                progress.console.print(f"[red]\t{_zip_filepath} ({file_size} is too large)", style="#e7f2fa")
                            # Add file to zip

                            zipObj.write(_zip_filepath, _rel_filepath)
                            progress.console.print(f"[green]\t{_zip_filepath}", style="#e7f2fa")
        if destination_dir is not None:
            dest_path = utils.resolve_path(destination_dir)
            # print(dest_path, dest_path.is_dir())
            if dest_path.is_dir():
                z_name = z_path.name
                z_final_path = dest_path/z_name
                z_path.rename(z_final_path)
                return z_final_path
            else:
                print(f"{destination_dir} is not a valid directory. Please use an absolute path or relative path.")
        return z_path