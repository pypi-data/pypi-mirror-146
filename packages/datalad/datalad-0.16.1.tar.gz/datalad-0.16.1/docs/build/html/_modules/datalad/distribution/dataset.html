<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>datalad.distribution.dataset &mdash; DataLad 0.15.3+529.gc81453444.dirty documentation</title>
      <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="../../../_static/graphviz.css" type="text/css" />
    <link rel="shortcut icon" href="../../../_static/favicon.ico"/>
  <!--[if lt IE 9]>
    <script src="../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../../../" id="documentation_options" src="../../../_static/documentation_options.js"></script>
        <script src="../../../_static/jquery.js"></script>
        <script src="../../../_static/underscore.js"></script>
        <script src="../../../_static/doctools.js"></script>
    <script src="../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="../../../index.html" class="icon icon-home"> DataLad
            <img src="../../../_static/datalad_logo.png" class="logo" alt="Logo"/>
          </a>
              <div class="version">
                0.15
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../../changelog.html">Change log</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../acknowledgements.html">Acknowledgments</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../publications.html">Publications</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../background.html">Background and motivation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../related.html">Delineation from related solutions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../basics.html">Basic principles</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../credentials.html">Credentials</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../metadata.html">Metadata</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../customization.html">Customization and extension of functionality</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../design/index.html">Design</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../glossary.html">Glossary</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../cmdline.html">Command line reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../modref.html">Python module reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../config.html">Configuration</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">DataLad</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../index.html" class="icon icon-home"></a> &raquo;</li>
          <li><a href="../../index.html">Module code</a> &raquo;</li>
      <li>datalad.distribution.dataset</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for datalad.distribution.dataset</h1><div class="highlight"><pre>
<span></span><span class="c1"># emacs: -*- mode: python; py-indent-offset: 4; tab-width: 4; indent-tabs-mode: nil -*-</span>
<span class="c1"># ex: set sts=4 ts=4 sw=4 et:</span>
<span class="c1"># ## ### ### ### ### ### ### ### ### ### ### ### ### ### ### ### ### ### ### ##</span>
<span class="c1">#</span>
<span class="c1">#   See COPYING file distributed along with the datalad package for the</span>
<span class="c1">#   copyright and license terms.</span>
<span class="c1">#</span>
<span class="c1"># ## ### ### ### ### ### ### ### ### ### ### ### ### ### ### ### ### ### ### ##</span>
<span class="sd">&quot;&quot;&quot;Implements class Dataset</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">import</span> <span class="nn">inspect</span>
<span class="kn">import</span> <span class="nn">logging</span>
<span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span> <span class="n">wraps</span>
<span class="kn">from</span> <span class="nn">os.path</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">curdir</span><span class="p">,</span>
    <span class="n">exists</span><span class="p">,</span>
    <span class="n">join</span> <span class="k">as</span> <span class="n">opj</span><span class="p">,</span>
    <span class="n">normpath</span><span class="p">,</span>
    <span class="n">pardir</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">weakref</span> <span class="kn">import</span> <span class="n">WeakValueDictionary</span>

<span class="kn">from</span> <span class="nn">datalad</span> <span class="kn">import</span> <span class="n">cfg</span>
<span class="kn">from</span> <span class="nn">datalad.config</span> <span class="kn">import</span> <span class="n">ConfigManager</span>
<span class="kn">from</span> <span class="nn">datalad.core.local.repo</span> <span class="kn">import</span> <span class="n">repo_from_path</span>
<span class="kn">from</span> <span class="nn">datalad.support.annexrepo</span> <span class="kn">import</span> <span class="n">AnnexRepo</span>
<span class="kn">from</span> <span class="nn">datalad.support.constraints</span> <span class="kn">import</span> <span class="n">Constraint</span>
<span class="c1"># DueCredit</span>
<span class="kn">from</span> <span class="nn">datalad.support.due</span> <span class="kn">import</span> <span class="n">due</span>
<span class="kn">from</span> <span class="nn">datalad.support.due_utils</span> <span class="kn">import</span> <span class="n">duecredit_dataset</span>
<span class="kn">from</span> <span class="nn">datalad.support.exceptions</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">NoDatasetFound</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">datalad.dataset.repo</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">path_based_str_repr</span><span class="p">,</span>
    <span class="n">PathBasedFlyweight</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">datalad.support.gitrepo</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">GitRepo</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">datalad.support</span> <span class="kn">import</span> <span class="n">path</span> <span class="k">as</span> <span class="n">op</span>

<span class="kn">import</span> <span class="nn">datalad.utils</span> <span class="k">as</span> <span class="nn">ut</span>
<span class="kn">from</span> <span class="nn">datalad.utils</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">getpwd</span><span class="p">,</span>
    <span class="n">optional_args</span><span class="p">,</span>
    <span class="n">get_dataset_root</span><span class="p">,</span>
    <span class="n">get_sig_param_names</span><span class="p">,</span>
    <span class="c1"># TODO remove after a while, when external consumers have adjusted</span>
    <span class="c1"># to use get_dataset_root()</span>
    <span class="n">get_dataset_root</span> <span class="k">as</span> <span class="n">rev_get_dataset_root</span><span class="p">,</span>
    <span class="n">Path</span><span class="p">,</span>
    <span class="n">PurePath</span><span class="p">,</span>
    <span class="n">ensure_list</span><span class="p">,</span>
<span class="p">)</span>


<span class="n">lgr</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="s1">&#39;datalad.dataset&#39;</span><span class="p">)</span>
<span class="n">lgr</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="s2">&quot;Importing dataset&quot;</span><span class="p">)</span>


<div class="viewcode-block" id="Dataset"><a class="viewcode-back" href="../../../generated/datalad.api.Dataset.html#datalad.api.Dataset">[docs]</a><span class="nd">@path_based_str_repr</span>
<span class="k">class</span> <span class="nc">Dataset</span><span class="p">(</span><span class="nb">object</span><span class="p">,</span> <span class="n">metaclass</span><span class="o">=</span><span class="n">PathBasedFlyweight</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Representation of a DataLad dataset/repository</span>

<span class="sd">    This is the core data type of DataLad: a representation of a dataset.</span>
<span class="sd">    At its core, datasets are (git-annex enabled) Git repositories. This</span>
<span class="sd">    class provides all operations that can be performed on a dataset.</span>

<span class="sd">    Creating a dataset instance is cheap, all actual operations are</span>
<span class="sd">    delayed until they are actually needed. Creating multiple `Dataset`</span>
<span class="sd">    class instances for the same Dataset location will automatically</span>
<span class="sd">    yield references to the same object.</span>

<span class="sd">    A dataset instance comprises of two major components: a `repo`</span>
<span class="sd">    attribute, and a `config` attribute. The former offers access to</span>
<span class="sd">    low-level functionality of the Git or git-annex repository. The</span>
<span class="sd">    latter gives access to a dataset&#39;s configuration manager.</span>

<span class="sd">    Most functionality is available via methods of this class, but also</span>
<span class="sd">    as stand-alone functions with the same name in `datalad.api`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Begin Flyweight</span>
    <span class="n">_unique_instances</span> <span class="o">=</span> <span class="n">WeakValueDictionary</span><span class="p">()</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">_flyweight_preproc_path</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">path</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Custom handling for few special abbreviations for datasets&quot;&quot;&quot;</span>
        <span class="n">path_</span> <span class="o">=</span> <span class="n">path</span>
        <span class="k">if</span> <span class="n">path</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;^&#39;</span><span class="p">,</span> <span class="s1">&#39;^.&#39;</span><span class="p">):</span>
            <span class="n">dsroot</span> <span class="o">=</span> <span class="n">get_dataset_root</span><span class="p">(</span><span class="n">curdir</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">dsroot</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">NoDatasetFound</span><span class="p">(</span><span class="s1">&#39;No dataset contains path: </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="nb">str</span><span class="p">(</span><span class="n">Path</span><span class="o">.</span><span class="n">cwd</span><span class="p">())))</span>
            <span class="k">if</span> <span class="n">path</span> <span class="o">==</span> <span class="s1">&#39;^&#39;</span><span class="p">:</span>
                <span class="c1"># get the topmost dataset from current location. Note that &#39;zsh&#39;</span>
                <span class="c1"># might have its ideas on what to do with ^, so better use as -d^</span>
                <span class="n">path_</span> <span class="o">=</span> <span class="n">Dataset</span><span class="p">(</span><span class="n">dsroot</span><span class="p">)</span><span class="o">.</span><span class="n">get_superdataset</span><span class="p">(</span>
                    <span class="n">topmost</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span><span class="o">.</span><span class="n">path</span>
            <span class="k">elif</span> <span class="n">path</span> <span class="o">==</span> <span class="s1">&#39;^.&#39;</span><span class="p">:</span>
                <span class="c1"># the dataset containing current directory</span>
                <span class="n">path_</span> <span class="o">=</span> <span class="n">dsroot</span>
        <span class="k">elif</span> <span class="n">path</span> <span class="o">==</span> <span class="s1">&#39;///&#39;</span><span class="p">:</span>
            <span class="c1"># TODO: logic/UI on installing a default dataset could move here</span>
            <span class="c1"># from search?</span>
            <span class="n">path_</span> <span class="o">=</span> <span class="n">cfg</span><span class="o">.</span><span class="n">obtain</span><span class="p">(</span><span class="s1">&#39;datalad.locations.default-dataset&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">path</span> <span class="o">!=</span> <span class="n">path_</span><span class="p">:</span>
            <span class="n">lgr</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Resolved dataset alias </span><span class="si">%r</span><span class="s2"> to path </span><span class="si">%r</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">path_</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">path_</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">_flyweight_postproc_path</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">path</span><span class="p">):</span>
        <span class="c1"># we want an absolute path, but no resolved symlinks</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">op</span><span class="o">.</span><span class="n">isabs</span><span class="p">(</span><span class="n">path</span><span class="p">):</span>
            <span class="n">path</span> <span class="o">=</span> <span class="n">op</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">op</span><span class="o">.</span><span class="n">getpwd</span><span class="p">(),</span> <span class="n">path</span><span class="p">)</span>

        <span class="c1"># use canonical paths only:</span>
        <span class="k">return</span> <span class="n">op</span><span class="o">.</span><span class="n">normpath</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_flyweight_invalid</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Invalidation of Flyweight instance</span>

<span class="sd">        Dataset doesn&#39;t need to be invalidated during its lifetime at all. Instead the underlying *Repo instances are.</span>
<span class="sd">        Dataset itself can represent a not yet existing path.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="kc">False</span>
    <span class="c1"># End Flyweight</span>

    <span class="k">def</span> <span class="fm">__hash__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># the flyweight key is already determining unique instances</span>
        <span class="c1"># add the class name to distinguish from strings of a path</span>
        <span class="k">return</span> <span class="nb">hash</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__weakref__</span><span class="o">.</span><span class="n">key</span><span class="p">))</span>

<div class="viewcode-block" id="Dataset.__init__"><a class="viewcode-back" href="../../../generated/datalad.api.Dataset.html#datalad.api.Dataset.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        path : str or Path</span>
<span class="sd">          Path to the dataset location. This location may or may not exist</span>
<span class="sd">          yet.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_pathobj</span> <span class="o">=</span> <span class="n">path</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">ut</span><span class="o">.</span><span class="n">Path</span><span class="p">)</span> <span class="k">else</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">ut</span><span class="o">.</span><span class="n">PurePath</span><span class="p">):</span>
            <span class="n">path</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_path</span> <span class="o">=</span> <span class="n">path</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_repo</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_id</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_cfg</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_cfg_bound</span> <span class="o">=</span> <span class="kc">None</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">pathobj</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;pathobj for the dataset&quot;&quot;&quot;</span>
        <span class="c1"># XXX this relies on the assumption that self._path as managed</span>
        <span class="c1"># by the base class is always a native path</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pathobj</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_pathobj</span> <span class="o">=</span> <span class="n">ut</span><span class="o">.</span><span class="n">Path</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_path</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pathobj</span>

    <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="s1">&#39;pathobj&#39;</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="c1"># Ben: https://github.com/datalad/datalad/pull/4057#discussion_r370153586</span>
        <span class="c1"># It&#39;s pointing to the same thing, while not being the same object</span>
        <span class="c1"># (in opposition to the *Repo classes). So `ds1 == ds2`,</span>
        <span class="c1"># `but ds1 is not ds2.` I thought that&#39;s a useful distinction. On the</span>
        <span class="c1"># other hand, I don&#39;t think we use it anywhere outside tests yet.</span>
        <span class="n">me_exists</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pathobj</span><span class="o">.</span><span class="n">exists</span><span class="p">()</span>
        <span class="n">other_exists</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">pathobj</span><span class="o">.</span><span class="n">exists</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">me_exists</span> <span class="o">!=</span> <span class="n">other_exists</span><span class="p">:</span>
            <span class="c1"># no chance this could be the same</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">elif</span> <span class="n">me_exists</span><span class="p">:</span>
            <span class="c1"># check on filesystem</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">pathobj</span><span class="o">.</span><span class="n">samefile</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">pathobj</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># we can only do lexical comparison.</span>
            <span class="c1"># this will fail to compare a long and a shortpath.</span>
            <span class="c1"># on windows that could actually point to the same thing</span>
            <span class="c1"># if it would exists, but this is how far we go with this.</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">pathobj</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">pathobj</span>

    <span class="k">def</span> <span class="fm">__getattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attr</span><span class="p">):</span>
        <span class="c1"># Assure that we are not just missing some late binding @datasetmethod .</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">attr</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;_&#39;</span><span class="p">):</span>  <span class="c1"># do not even consider those</span>
            <span class="n">lgr</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Importing datalad.api to possibly discover possibly not yet bound method </span><span class="si">%r</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">attr</span><span class="p">)</span>
            <span class="c1"># load entire datalad.api which will also bind datasetmethods</span>
            <span class="c1"># from extensions.</span>
            <span class="kn">import</span> <span class="nn">datalad.api</span>
            <span class="c1"># which would bind all known interfaces as well.</span>
            <span class="c1"># Although adds overhead, good for UX</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">(</span><span class="n">Dataset</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__getattribute__</span><span class="p">(</span><span class="n">attr</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">close</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Perform operations which would close any possible process using this Dataset</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">repo</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_repo</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_repo</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">repo</span><span class="p">:</span>
            <span class="c1"># might take care about lingering batched processes etc</span>
            <span class="k">del</span> <span class="n">repo</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">path</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;path to the dataset&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_path</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">repo</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get an instance of the version control system/repo for this dataset,</span>
<span class="sd">        or None if there is none yet (or none anymore).</span>

<span class="sd">        If testing the validity of an instance of GitRepo is guaranteed to be</span>
<span class="sd">        really cheap this could also serve as a test whether a repo is present.</span>

<span class="sd">        Note, that this property is evaluated every time it is used. If used</span>
<span class="sd">        multiple times within a function it&#39;s probably a good idea to store its</span>
<span class="sd">        value in a local variable and use this variable instead.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        GitRepo or AnnexRepo</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># If we already got a *Repo instance, check whether it&#39;s still valid;</span>
        <span class="c1"># Note, that this basically does part of the testing that would</span>
        <span class="c1"># (implicitly) be done in the loop below again. So, there&#39;s still</span>
        <span class="c1"># potential to speed up when we actually need to get a new instance</span>
        <span class="c1"># (or none). But it&#39;s still faster for the vast majority of cases.</span>
        <span class="c1">#</span>
        <span class="c1"># TODO: Dig deeper into it and melt with new instance guessing. This</span>
        <span class="c1"># should also involve to reduce redundancy of testing such things from</span>
        <span class="c1"># within Flyweight.__call__, AnnexRepo.__init__ and GitRepo.__init__!</span>
        <span class="c1">#</span>
        <span class="c1"># Also note, that this could be forged into a single big condition, but</span>
        <span class="c1"># that is hard to read and we should be well aware of the actual</span>
        <span class="c1"># criteria here:</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_repo</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">pathobj</span><span class="o">.</span><span class="n">resolve</span><span class="p">()</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">_repo</span><span class="o">.</span><span class="n">pathobj</span><span class="p">:</span>
            <span class="c1"># we got a repo and path references still match</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_repo</span><span class="p">,</span> <span class="n">AnnexRepo</span><span class="p">):</span>
                <span class="c1"># it&#39;s supposed to be an annex</span>
                <span class="c1"># Here we do the same validation that Flyweight would do beforehand if there was a call to AnnexRepo()</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_repo</span> <span class="ow">is</span> <span class="n">AnnexRepo</span><span class="o">.</span><span class="n">_unique_instances</span><span class="o">.</span><span class="n">get</span><span class="p">(</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">_repo</span><span class="o">.</span><span class="n">path</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_repo</span><span class="o">.</span><span class="n">_flyweight_invalid</span><span class="p">():</span>
                    <span class="c1"># it&#39;s still the object registered as flyweight and it&#39;s a</span>
                    <span class="c1"># valid annex repo</span>
                    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_repo</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_repo</span><span class="p">,</span> <span class="n">GitRepo</span><span class="p">):</span>
                <span class="c1"># it&#39;s supposed to be a plain git</span>
                <span class="c1"># same kind of checks as for AnnexRepo above, but additionally check whether it was changed to have an</span>
                <span class="c1"># annex now.</span>
                <span class="c1"># TODO: Instead of is_with_annex, we might want the cheaper check for an actually initialized annex.</span>
                <span class="c1">#       However, that&#39;s not completely clear. On the one hand, if it really changed to be an annex</span>
                <span class="c1">#       it seems likely that this happened locally and it would also be an initialized annex. On the</span>
                <span class="c1">#       other hand, we could have added (and fetched) a remote with an annex, which would turn it into</span>
                <span class="c1">#       our current notion of an uninitialized annex. Question is whether or not such a change really</span>
                <span class="c1">#       need to be detected. For now stay on the safe side and detect it.</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_repo</span> <span class="ow">is</span> <span class="n">GitRepo</span><span class="o">.</span><span class="n">_unique_instances</span><span class="o">.</span><span class="n">get</span><span class="p">(</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">_repo</span><span class="o">.</span><span class="n">path</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_repo</span><span class="o">.</span><span class="n">_flyweight_invalid</span><span class="p">()</span> <span class="ow">and</span> <span class="ow">not</span> \
                        <span class="bp">self</span><span class="o">.</span><span class="n">_repo</span><span class="o">.</span><span class="n">is_with_annex</span><span class="p">():</span>
                    <span class="c1"># it&#39;s still the object registered as flyweight, it&#39;s a</span>
                    <span class="c1"># valid git repo and it hasn&#39;t turned into an annex</span>
                    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_repo</span>

        <span class="c1"># Note: Although it looks like the &quot;self._repo = None&quot; assignments</span>
        <span class="c1"># could be used instead of variable &quot;valid&quot;, that&#39;s a big difference!</span>
        <span class="c1"># The *Repo instances are flyweights, not singletons. self._repo might</span>
        <span class="c1"># be the last reference, which would lead to those objects being</span>
        <span class="c1"># destroyed and therefore the constructor call would result in an</span>
        <span class="c1"># actually new instance. This is unnecessarily costly.</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_repo</span> <span class="o">=</span> <span class="n">repo_from_path</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_path</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
            <span class="n">lgr</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="s2">&quot;Failed to detect a valid repo at </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">path</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_repo</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">return</span>

        <span class="k">if</span> <span class="n">due</span><span class="o">.</span><span class="n">active</span><span class="p">:</span>
            <span class="c1"># TODO: Figure out, when exactly this is needed. Don&#39;t think it</span>
            <span class="c1">#       makes sense to do this for every dataset,</span>
            <span class="c1">#       no matter what =&gt; we want .repo to be as cheap as it gets.</span>
            <span class="c1"># Makes sense only on installed dataset - @never_fail&#39;ed</span>
            <span class="n">duecredit_dataset</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_repo</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">id</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Identifier of the dataset.</span>

<span class="sd">        This identifier is supposed to be unique across datasets, but identical</span>
<span class="sd">        for different versions of the same dataset (that have all been derived</span>
<span class="sd">        from the same original dataset repository).</span>

<span class="sd">        Note, that a plain git/git-annex repository doesn&#39;t necessarily have</span>
<span class="sd">        a dataset id yet. It is created by `Dataset.create()` and stored in</span>
<span class="sd">        .datalad/config. If None is returned while there is a valid repository,</span>
<span class="sd">        there may have never been a call to `create` in this branch before</span>
<span class="sd">        current commit.</span>

<span class="sd">        Note, that this property is evaluated every time it is used. If used</span>
<span class="sd">        multiple times within a function it&#39;s probably a good idea to store its</span>
<span class="sd">        value in a local variable and use this variable instead.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        str</span>
<span class="sd">          This is either a stored UUID, or `None`.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;datalad.dataset.id&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">config</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get an instance of the parser for the persistent dataset configuration.</span>

<span class="sd">        Note, that this property is evaluated every time it is used. If used</span>
<span class="sd">        multiple times within a function it&#39;s probably a good idea to store its</span>
<span class="sd">        value in a local variable and use this variable instead.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        ConfigManager</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># OPT: be &quot;smart&quot; and avoid re-resolving .repo -- expensive in DataLad</span>
        <span class="n">repo</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">repo</span>
        <span class="k">if</span> <span class="n">repo</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># if there&#39;s no repo (yet or anymore), we can&#39;t read/write config at</span>
            <span class="c1"># dataset level, but only at user/system level</span>
            <span class="c1"># However, if this was the case before as well, we don&#39;t want a new</span>
            <span class="c1"># instance of ConfigManager</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cfg_bound</span> <span class="ow">in</span> <span class="p">(</span><span class="kc">True</span><span class="p">,</span> <span class="kc">None</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_cfg</span> <span class="o">=</span> <span class="n">ConfigManager</span><span class="p">(</span><span class="n">dataset</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_cfg_bound</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_cfg</span> <span class="o">=</span> <span class="n">repo</span><span class="o">.</span><span class="n">config</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_cfg_bound</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cfg</span>

    <span class="k">def</span> <span class="nf">recall_state</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">whereto</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Something that can be used to checkout a particular state</span>
<span class="sd">        (tag, commit) to &quot;undo&quot; a change or switch to a otherwise desired</span>
<span class="sd">        previous state.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        whereto: str</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_installed</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span>
                <span class="s2">&quot;cannot remember a state when a dataset is not yet installed&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">repo</span><span class="o">.</span><span class="n">checkout</span><span class="p">(</span><span class="n">whereto</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">is_installed</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns whether a dataset is installed.</span>

<span class="sd">        A dataset is installed when a repository for it exists on the filesystem.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        bool</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">path</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">exists</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">path</span><span class="p">)</span> <span class="ow">and</span> \
            <span class="bp">self</span><span class="o">.</span><span class="n">repo</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">get_superdataset</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">datalad_only</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">topmost</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                         <span class="n">registered_only</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get the dataset&#39;s superdataset</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        datalad_only : bool, optional</span>
<span class="sd">          Whether to consider only &quot;datalad datasets&quot; (with non-None</span>
<span class="sd">          id), or (if False, which is default) - any git repository</span>
<span class="sd">        topmost : bool, optional</span>
<span class="sd">          Return the topmost super-dataset. Might then be the current one.</span>
<span class="sd">        registered_only : bool, optional</span>
<span class="sd">          Test whether any discovered superdataset actually contains the</span>
<span class="sd">          dataset in question as a registered subdataset (as opposed to</span>
<span class="sd">          just being located in a subdirectory without a formal relationship).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Dataset or None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">path</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">path</span>
        <span class="n">sds_path</span> <span class="o">=</span> <span class="n">path</span> <span class="k">if</span> <span class="n">topmost</span> <span class="k">else</span> <span class="kc">None</span>

        <span class="k">def</span> <span class="nf">res_filter</span><span class="p">(</span><span class="n">res</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">res</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;status&#39;</span><span class="p">)</span> <span class="o">==</span> <span class="s1">&#39;ok&#39;</span> <span class="ow">and</span> <span class="n">res</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;type&#39;</span><span class="p">)</span> <span class="o">==</span> <span class="s1">&#39;dataset&#39;</span>

        <span class="k">def</span> <span class="nf">subds_contains_path</span><span class="p">(</span><span class="n">ds</span><span class="p">,</span> <span class="n">path</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">path</span> <span class="ow">in</span> <span class="n">sds</span><span class="o">.</span><span class="n">subdatasets</span><span class="p">(</span><span class="n">recursive</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                           <span class="n">contains</span><span class="o">=</span><span class="n">path</span><span class="p">,</span>
                                           <span class="n">result_filter</span><span class="o">=</span><span class="n">res_filter</span><span class="p">,</span>
                                           <span class="n">on_failure</span><span class="o">=</span><span class="s1">&#39;ignore&#39;</span><span class="p">,</span>
                                           <span class="n">result_xfm</span><span class="o">=</span><span class="s1">&#39;paths&#39;</span><span class="p">,</span>
                                           <span class="n">result_renderer</span><span class="o">=</span><span class="s1">&#39;disabled&#39;</span><span class="p">)</span>

        <span class="k">while</span> <span class="n">path</span><span class="p">:</span>
            <span class="c1"># normalize the path after adding .. so we guaranteed to not</span>
            <span class="c1"># follow into original directory if path itself is a symlink</span>
            <span class="n">par_path</span> <span class="o">=</span> <span class="n">normpath</span><span class="p">(</span><span class="n">opj</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">pardir</span><span class="p">))</span>
            <span class="n">sds_path_</span> <span class="o">=</span> <span class="n">get_dataset_root</span><span class="p">(</span><span class="n">par_path</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">sds_path_</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1"># no more parents, use previous found</span>
                <span class="k">break</span>

            <span class="n">sds</span> <span class="o">=</span> <span class="n">Dataset</span><span class="p">(</span><span class="n">sds_path_</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">datalad_only</span><span class="p">:</span>
                <span class="c1"># test if current git is actually a dataset?</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">sds</span><span class="o">.</span><span class="n">id</span><span class="p">:</span>
                    <span class="k">break</span>
            <span class="k">if</span> <span class="n">registered_only</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">subds_contains_path</span><span class="p">(</span><span class="n">sds</span><span class="p">,</span> <span class="n">path</span><span class="p">):</span>
                    <span class="k">break</span>

            <span class="c1"># That was a good candidate</span>
            <span class="n">sds_path</span> <span class="o">=</span> <span class="n">sds_path_</span>
            <span class="n">path</span> <span class="o">=</span> <span class="n">par_path</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">topmost</span><span class="p">:</span>
                <span class="c1"># no looping</span>
                <span class="k">break</span>

        <span class="k">if</span> <span class="n">sds_path</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># None was found</span>
            <span class="k">return</span> <span class="kc">None</span>

        <span class="c1"># No postprocessing now should be necessary since get_toppath</span>
        <span class="c1"># tries its best to not resolve symlinks now</span>

        <span class="k">return</span> <span class="n">Dataset</span><span class="p">(</span><span class="n">sds_path</span><span class="p">)</span></div>


<span class="nd">@optional_args</span>
<span class="k">def</span> <span class="nf">datasetmethod</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">dataset_argname</span><span class="o">=</span><span class="s1">&#39;dataset&#39;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Decorator to bind functions to Dataset class.</span>

<span class="sd">    The decorated function is still directly callable and additionally serves</span>
<span class="sd">    as method `name` of class Dataset.  To achieve this, the first positional</span>
<span class="sd">    argument is redirected to original keyword argument &#39;dataset_argname&#39;. All</span>
<span class="sd">    other arguments stay in order (and keep their names, of course). That</span>
<span class="sd">    means, that the signature of the bound function is name(self, a, b) if the</span>
<span class="sd">    original signature is name(a, dataset, b) for example.</span>

<span class="sd">    The decorator has no effect on the actual function decorated with it.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">name</span><span class="p">:</span>
        <span class="n">name</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="vm">__name__</span>

    <span class="nd">@wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">apply_func</span><span class="p">(</span><span class="n">instance</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="c1"># Wrapper function to assign arguments of the bound function to</span>
        <span class="c1"># original function.</span>
        <span class="c1">#</span>
        <span class="c1"># Note</span>
        <span class="c1"># ----</span>
        <span class="c1"># This wrapper is NOT returned by the decorator, but only used to bind</span>
        <span class="c1"># the function `f` to the Dataset class.</span>
        <span class="n">kwargs</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="c1"># due to use of functools.wraps and inability of of getarspec to get</span>
        <span class="c1"># those, we use .signature.</span>
        <span class="c1"># More information in de-wrapt PR https://github.com/datalad/datalad/pull/6190</span>
        <span class="kn">from</span> <span class="nn">datalad.utils</span> <span class="kn">import</span> <span class="n">get_sig_param_names</span>
        <span class="n">f_args</span><span class="p">,</span> <span class="n">f_kwonlyargs</span> <span class="o">=</span> <span class="n">get_sig_param_names</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="p">(</span><span class="s1">&#39;pos_any&#39;</span><span class="p">,</span> <span class="s1">&#39;kw_only&#39;</span><span class="p">))</span>

        <span class="c1"># If bound function is used with wrong signature (especially by</span>
        <span class="c1"># explicitly passing a dataset), let&#39;s raise a proper exception instead</span>
        <span class="c1"># of a &#39;list index out of range&#39;, that is not very telling to the user.</span>
        <span class="c1"># In case whenever kwonlyargs are used, &#39;dataset&#39; would not be listed</span>
        <span class="c1"># among args, so we would account for it (possibly) be there.</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">f_args</span><span class="p">)</span> <span class="o">+</span> <span class="nb">int</span><span class="p">(</span><span class="nb">bool</span><span class="p">(</span><span class="n">f_kwonlyargs</span><span class="p">)):</span>
            <span class="n">non_dataset_args</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;self&quot;</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="n">a</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">f_args</span> <span class="k">if</span> <span class="n">a</span> <span class="o">!=</span> <span class="n">dataset_argname</span><span class="p">]</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2">() takes at most </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">f_args</span><span class="p">)</span><span class="si">}</span><span class="s2"> arguments (</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span><span class="si">}</span><span class="s2"> given): &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">non_dataset_args</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">dataset_argname</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2">() got an unexpected keyword argument </span><span class="si">{</span><span class="n">dataset_argname</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">kwargs</span><span class="p">[</span><span class="n">dataset_argname</span><span class="p">]</span> <span class="o">=</span> <span class="n">instance</span>
        <span class="k">if</span> <span class="n">dataset_argname</span> <span class="ow">in</span> <span class="n">f_kwonlyargs</span><span class="p">:</span>
            <span class="c1"># * was used to enforce kwargs, so we just would pass things as is</span>
            <span class="k">pass</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># so it is &quot;old&quot; style, where it is a regular kwargs - we pass everything</span>
            <span class="c1"># via kwargs</span>
            <span class="c1"># TODO: issue a DX oriented warning that we advise to separate out kwargs,</span>
            <span class="c1"># dataset included, with * from positional args?</span>
            <span class="n">ds_index</span> <span class="o">=</span> <span class="n">f_args</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">dataset_argname</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)):</span>
                <span class="k">if</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">ds_index</span><span class="p">:</span>
                    <span class="n">kwargs</span><span class="p">[</span><span class="n">f_args</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="k">elif</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="n">ds_index</span><span class="p">:</span>
                    <span class="n">kwargs</span><span class="p">[</span><span class="n">f_args</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]]</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">args</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">return</span> <span class="n">f</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="nb">setattr</span><span class="p">(</span><span class="n">Dataset</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">apply_func</span><span class="p">)</span>
    <span class="c1"># set the ad-hoc attribute so that @build_doc could also bind built doc</span>
    <span class="c1"># to the dataset method</span>
    <span class="k">if</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="s1">&#39;_dataset_method&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;_dataset_method of </span><span class="si">{</span><span class="n">f</span><span class="si">}</span><span class="s2"> is already set to </span><span class="si">{</span><span class="n">f</span><span class="o">.</span><span class="n">_dataset_method</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="nb">setattr</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="s1">&#39;_dataset_method&#39;</span><span class="p">,</span> <span class="n">apply_func</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">f</span>


<span class="c1"># Note: Cannot be defined within constraints.py, since then dataset.py needs to</span>
<span class="c1"># be imported from constraints.py, which needs to be imported from dataset.py</span>
<span class="c1"># for another constraint</span>
<span class="k">class</span> <span class="nc">EnsureDataset</span><span class="p">(</span><span class="n">Constraint</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Despite its name, this constraint does not actually ensure that the</span>
<span class="sd">    argument is a valid dataset, because for procedural reasons this would</span>
<span class="sd">    typically duplicate subsequent checks and processing. However, it can</span>
<span class="sd">    be used to achieve uniform documentation of `dataset` arguments.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">Dataset</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">value</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="c1"># we cannot convert to a Dataset class right here</span>
            <span class="c1"># - duplicates require_dataset() later on</span>
            <span class="c1"># - we need to be able to distinguish between a bound</span>
            <span class="c1">#   dataset method call and a standalone call for</span>
            <span class="c1">#   relative path argument disambiguation</span>
            <span class="c1">#return Dataset(path=value)</span>
            <span class="k">return</span> <span class="n">value</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Can&#39;t create Dataset from </span><span class="si">%s</span><span class="s2">.&quot;</span> <span class="o">%</span> <span class="nb">type</span><span class="p">(</span><span class="n">value</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">short_description</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s2">&quot;Dataset&quot;</span>

    <span class="k">def</span> <span class="nf">long_description</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s2">&quot;&quot;&quot;Value must be a Dataset or a valid identifier of a Dataset</span>
<span class="s2">        (e.g. a path)&quot;&quot;&quot;</span>


<span class="k">def</span> <span class="nf">require_dataset</span><span class="p">(</span><span class="n">dataset</span><span class="p">,</span> <span class="n">check_installed</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">purpose</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Helper function to resolve a dataset.</span>

<span class="sd">    This function tries to resolve a dataset given an input argument,</span>
<span class="sd">    or based on the process&#39; working directory, if `None` is given.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    dataset : None or path or Dataset</span>
<span class="sd">      Some value identifying a dataset or `None`. In the latter case</span>
<span class="sd">      a dataset will be searched based on the process working directory.</span>
<span class="sd">    check_installed : bool, optional</span>
<span class="sd">      If True, an optional check whether the resolved dataset is</span>
<span class="sd">      properly installed will be performed.</span>
<span class="sd">    purpose : str, optional</span>
<span class="sd">      This string will be inserted in error messages to make them more</span>
<span class="sd">      informative. The pattern is &quot;... dataset for &lt;STRING&gt;&quot;.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    Dataset</span>
<span class="sd">      Or raises an exception (InsufficientArgumentsError).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">dataset</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dataset</span><span class="p">,</span> <span class="n">Dataset</span><span class="p">):</span>
        <span class="n">dataset</span> <span class="o">=</span> <span class="n">Dataset</span><span class="p">(</span><span class="n">dataset</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">dataset</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>  <span class="c1"># possible scenario of cmdline calls</span>
        <span class="n">dspath</span> <span class="o">=</span> <span class="n">get_dataset_root</span><span class="p">(</span><span class="n">getpwd</span><span class="p">())</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">dspath</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">NoDatasetFound</span><span class="p">(</span>
                <span class="s2">&quot;No dataset found at &#39;</span><span class="si">{}</span><span class="s2">&#39;</span><span class="si">{}</span><span class="s2">.  Specify a dataset to work with &quot;</span>
                <span class="s2">&quot;by providing its path via the `dataset` option, &quot;</span>
                <span class="s2">&quot;or change the current working directory to be in a &quot;</span>
                <span class="s2">&quot;dataset.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="n">getpwd</span><span class="p">(),</span>
                    <span class="s2">&quot; for the purpose </span><span class="si">{!r}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">purpose</span><span class="p">)</span> <span class="k">if</span> <span class="n">purpose</span> <span class="k">else</span> <span class="s1">&#39;&#39;</span>
                <span class="p">)</span>
            <span class="p">)</span>
        <span class="n">dataset</span> <span class="o">=</span> <span class="n">Dataset</span><span class="p">(</span><span class="n">dspath</span><span class="p">)</span>

    <span class="k">assert</span><span class="p">(</span><span class="n">dataset</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span>
    <span class="n">lgr</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">u</span><span class="s2">&quot;Resolved dataset</span><span class="si">%s</span><span class="s2">: </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span>
              <span class="sa">u</span><span class="s1">&#39; to </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">purpose</span><span class="p">)</span> <span class="k">if</span> <span class="n">purpose</span> <span class="k">else</span> <span class="s1">&#39;&#39;</span><span class="p">,</span>
              <span class="n">dataset</span><span class="o">.</span><span class="n">path</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">check_installed</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">dataset</span><span class="o">.</span><span class="n">is_installed</span><span class="p">():</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">u</span><span class="s2">&quot;No installed dataset found at &quot;</span>
                         <span class="sa">u</span><span class="s2">&quot;</span><span class="si">{0}</span><span class="s2">.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">dataset</span><span class="o">.</span><span class="n">path</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">dataset</span>


<span class="c1"># New helpers, courtesy of datalad-revolution.</span>


<span class="c1"># note: not thread safe if threads chdir - uses getpwd</span>
<span class="k">def</span> <span class="nf">resolve_path</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">ds</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">ds_resolved</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Resolve a path specification (against a Dataset location)</span>

<span class="sd">    Any path is returned as an absolute path. If, and only if, a dataset</span>
<span class="sd">    object instance is given as `ds`, relative paths are interpreted as</span>
<span class="sd">    relative to the given dataset. In all other cases, relative paths are</span>
<span class="sd">    treated as relative to the current working directory.</span>

<span class="sd">    Note however, that this function is not able to resolve arbitrarily</span>
<span class="sd">    obfuscated path specifications. All operations are purely lexical, and no</span>
<span class="sd">    actual path resolution against the filesystem content is performed.</span>
<span class="sd">    Consequently, common relative path arguments like &#39;../something&#39; (relative</span>
<span class="sd">    to PWD) can be handled properly, but things like &#39;down/../under&#39; cannot, as</span>
<span class="sd">    resolving this path properly depends on the actual target of any</span>
<span class="sd">    (potential) symlink leading up to &#39;..&#39;.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    path : str or PathLike or list</span>
<span class="sd">      Platform-specific path specific path specification. Multiple path</span>
<span class="sd">      specifications can be given as a list</span>
<span class="sd">    ds : Dataset or PathLike or None</span>
<span class="sd">      Dataset instance to resolve relative paths against.</span>
<span class="sd">    ds_resolved : Dataset or None</span>
<span class="sd">      A dataset instance that was created from `ds` outside can be provided</span>
<span class="sd">      to avoid multiple instantiation on repeated calls.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    `pathlib.Path` object or list(Path)</span>
<span class="sd">      When a list was given as input a list is returned, a Path instance</span>
<span class="sd">      otherwise.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">got_ds_instance</span> <span class="o">=</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ds</span><span class="p">,</span> <span class="n">Dataset</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">ds</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">got_ds_instance</span><span class="p">:</span>
        <span class="n">ds</span> <span class="o">=</span> <span class="n">ds_resolved</span> <span class="ow">or</span> <span class="n">require_dataset</span><span class="p">(</span>
            <span class="n">ds</span><span class="p">,</span> <span class="n">check_installed</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">purpose</span><span class="o">=</span><span class="s1">&#39;path resolution&#39;</span><span class="p">)</span>
    <span class="n">out</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">pwd_parts</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># get it upon first use but only once</span>
    <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">ensure_list</span><span class="p">(</span><span class="n">path</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">ds</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">got_ds_instance</span><span class="p">:</span>
            <span class="c1"># no dataset at all or no instance provided -&gt; CWD is always the reference</span>
            <span class="c1"># nothing needs to be done here. Path-conversion and absolutification</span>
            <span class="c1"># are done next</span>
            <span class="k">pass</span>
        <span class="c1"># we have a given datasets instance</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="n">Path</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="o">.</span><span class="n">is_absolute</span><span class="p">():</span>
            <span class="c1"># we have a dataset and no abspath nor an explicit relative path -&gt;</span>
            <span class="c1"># resolve it against the dataset</span>
            <span class="n">p</span> <span class="o">=</span> <span class="n">ds</span><span class="o">.</span><span class="n">pathobj</span> <span class="o">/</span> <span class="n">p</span>

        <span class="n">p</span> <span class="o">=</span> <span class="n">ut</span><span class="o">.</span><span class="n">Path</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>

        <span class="c1"># make sure we return an absolute path, but without actually</span>
        <span class="c1"># resolving anything</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">p</span><span class="o">.</span><span class="n">is_absolute</span><span class="p">():</span>
            <span class="c1"># in general it is almost impossible to use resolve() when</span>
            <span class="c1"># we can have symlinks in the root path of a dataset</span>
            <span class="c1"># (that we don&#39;t want to resolve here), symlinks to annex&#39;ed</span>
            <span class="c1"># files (that we never want to resolve), and other within-repo</span>
            <span class="c1"># symlinks that we (sometimes) want to resolve (i.e. symlinked</span>
            <span class="c1"># paths for addressing content vs adding content)</span>
            <span class="c1"># CONCEPT: do the minimal thing to catch most real-world inputs</span>
            <span class="c1"># ASSUMPTION: the only sane relative path input that needs</span>
            <span class="c1"># handling and can be handled are upward references like</span>
            <span class="c1"># &#39;../../some/that&#39;, whereas stuff like &#39;down/../someotherdown&#39;</span>
            <span class="c1"># are intellectual exercises</span>
            <span class="c1"># ALGORITHM: match any number of leading &#39;..&#39; path components</span>
            <span class="c1"># and shorten the PWD by that number</span>
            <span class="c1"># NOT using ut.Path.cwd(), because it has symlinks resolved!!</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">pwd_parts</span><span class="p">:</span>
                <span class="n">pwd_parts</span> <span class="o">=</span> <span class="n">ut</span><span class="o">.</span><span class="n">Path</span><span class="p">(</span><span class="n">getpwd</span><span class="p">())</span><span class="o">.</span><span class="n">parts</span>
            <span class="n">path_parts</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">parts</span>
            <span class="n">leading_parents</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">pp</span> <span class="ow">in</span> <span class="n">p</span><span class="o">.</span><span class="n">parts</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">pp</span> <span class="o">==</span> <span class="n">op</span><span class="o">.</span><span class="n">pardir</span><span class="p">:</span>
                    <span class="n">leading_parents</span> <span class="o">+=</span> <span class="mi">1</span>
                    <span class="n">path_parts</span> <span class="o">=</span> <span class="n">path_parts</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
                <span class="k">elif</span> <span class="n">pp</span> <span class="o">==</span> <span class="n">op</span><span class="o">.</span><span class="n">curdir</span><span class="p">:</span>
                    <span class="c1"># we want to discard that, but without stripping</span>
                    <span class="c1"># a corresponding parent</span>
                    <span class="n">path_parts</span> <span class="o">=</span> <span class="n">path_parts</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">break</span>
            <span class="n">p</span> <span class="o">=</span> <span class="n">ut</span><span class="o">.</span><span class="n">Path</span><span class="p">(</span>
                <span class="n">op</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
                    <span class="o">*</span><span class="p">(</span><span class="n">pwd_parts</span><span class="p">[:</span><span class="o">-</span><span class="n">leading_parents</span> <span class="k">if</span> <span class="n">leading_parents</span> <span class="k">else</span> <span class="kc">None</span><span class="p">]</span>
                      <span class="o">+</span> <span class="n">path_parts</span><span class="p">)))</span>
        <span class="c1"># note that we will not &quot;normpath()&quot; the result, check the</span>
        <span class="c1"># pathlib docs for why this is the only sane choice in the</span>
        <span class="c1"># face of the possibility of symlinks in the path</span>
        <span class="n">out</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">out</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="n">PurePath</span><span class="p">))</span> <span class="k">else</span> <span class="n">out</span>

<span class="c1"># TODO keep this around for a while so that extensions can be updated</span>
<span class="n">rev_resolve_path</span> <span class="o">=</span> <span class="n">resolve_path</span>


<span class="k">def</span> <span class="nf">path_under_rev_dataset</span><span class="p">(</span><span class="n">ds</span><span class="p">,</span> <span class="n">path</span><span class="p">):</span>
    <span class="n">ds_path</span> <span class="o">=</span> <span class="n">ds</span><span class="o">.</span><span class="n">pathobj</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">rpath</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">ut</span><span class="o">.</span><span class="n">Path</span><span class="p">(</span><span class="n">path</span><span class="p">)</span><span class="o">.</span><span class="n">relative_to</span><span class="p">(</span><span class="n">ds_path</span><span class="p">))</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">rpath</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="n">op</span><span class="o">.</span><span class="n">pardir</span><span class="p">):</span>
            <span class="c1"># path is already underneath the dataset</span>
            <span class="k">return</span> <span class="n">path</span>
    <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
        <span class="c1"># whatever went wrong, we gotta play save</span>
        <span class="k">pass</span>

    <span class="n">root</span> <span class="o">=</span> <span class="n">get_dataset_root</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">path</span><span class="p">))</span>
    <span class="k">while</span> <span class="n">root</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">ds_path</span><span class="o">.</span><span class="n">samefile</span><span class="p">(</span><span class="n">root</span><span class="p">):</span>
        <span class="c1"># path and therefore root could be relative paths,</span>
        <span class="c1"># hence in the next round we cannot use dirname()</span>
        <span class="c1"># to jump in the the next directory up, but we have</span>
        <span class="c1"># to use ./.. and get_dataset_root() will handle</span>
        <span class="c1"># the rest just fine</span>
        <span class="n">root</span> <span class="o">=</span> <span class="n">get_dataset_root</span><span class="p">(</span><span class="n">op</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">op</span><span class="o">.</span><span class="n">pardir</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">root</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">None</span>
    <span class="k">return</span> <span class="n">ds_path</span> <span class="o">/</span> <span class="n">op</span><span class="o">.</span><span class="n">relpath</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">path</span><span class="p">),</span> <span class="n">root</span><span class="p">)</span>


<span class="n">lgr</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="s2">&quot;Done importing dataset&quot;</span><span class="p">)</span>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2016-2022, DataLad team.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>