{
  "create_replication_slot": "SELECT true FROM pg_create_physical_replication_slot(%(slot)s);",
  "database_alter": "ALTER DATABASE {database} {options};",
  "database_create": "CREATE DATABASE {database} {options};",
  "database_default_acl": "WITH default_acls AS (\n    SELECT\n        pg_namespace.nspname AS schema,\n        pg_default_acl.defaclobjtype AS objtype,\n        aclexplode(pg_default_acl.defaclacl) AS acl\n    FROM\n        pg_default_acl\n        JOIN pg_namespace ON pg_namespace.oid = pg_default_acl.defaclnamespace\n)\nSELECT\n    current_database() AS database,\n    default_acls.schema,\n    pg_roles.rolname AS role,\n    CASE default_acls.objtype\n    WHEN 'f' THEN\n        'FUNCTION'\n    WHEN 'r' THEN\n        'TABLE'\n    WHEN 'S' THEN\n        'SEQUENCE'\n    WHEN 'T' THEN\n        'TYPE'\n    WHEN 'n' THEN\n        'SCHEMA'\n    ELSE\n        'UNKNOWN'\n    END AS object_type,\n    array_agg(DISTINCT (default_acls.acl).privilege_type) AS privileges\nFROM\n    default_acls\n    JOIN pg_roles ON ((acl).grantee = pg_roles.oid)\n{where_clause}\nGROUP BY\n    schema,\n    role,\n    object_type\nORDER BY\n    schema,\n    role,\n    object_type;",
  "database_drop": "DROP DATABASE {database};",
  "database_exists": "SELECT true FROM pg_database WHERE datname = %(database)s;",
  "database_inspect": "SELECT\n    db.datname AS name,\n    r.rolname AS owner,\n    (\n        SELECT s.setconfig FROM pg_db_role_setting s\n        WHERE s.setdatabase = db.oid AND s.setrole = 0\n    ) AS settings\nFROM\n    pg_database db\n    JOIN pg_authid r ON db.datdba = r.oid\nWHERE\n    db.datname = %(datname)s;",
  "database_list": "SELECT d.datname as \"name\",\n    pg_catalog.pg_get_userbyid(d.datdba) as \"owner\",\n    pg_catalog.pg_encoding_to_char(d.encoding) as \"encoding\",\n    d.datcollate as \"collation\",\n    d.datctype as \"ctype\",\n    d.datacl AS \"acls\",\n    pg_catalog.pg_database_size(d.datname) as \"size\",\n    t.spcname as \"tablespace\",\n    pg_catalog.pg_tablespace_location(t.oid) as \"tablespace_location\",\n    pg_catalog.pg_tablespace_size(t.oid) as \"tablespace_size\",\n    pg_catalog.shobj_description(d.oid, 'pg_database') as \"description\"\nFROM pg_catalog.pg_database d\nJOIN pg_catalog.pg_tablespace t on d.dattablespace = t.oid\nWHERE datallowconn {where_clause}\nORDER BY 1;",
  "drop_replication_slot": "SELECT true FROM pg_drop_replication_slot((SELECT slot_name FROM pg_replication_slots WHERE slot_name = %(slot)s));",
  "role_alter": "ALTER ROLE {username} {options};",
  "role_create": "CREATE ROLE {username} {options};",
  "role_drop": "DROP ROLE {username};",
  "role_exists": "SELECT true FROM pg_roles WHERE rolname = %(username)s;",
  "role_grant": "GRANT {rolname} TO {rolspec};",
  "role_has_password": "SELECT\n    rolpassword IS NOT NULL as haspassword FROM pg_authid\nWHERE\n    rolname = %(username)s;",
  "role_inspect": "SELECT\n    r.rolname AS name,\n    CASE WHEN r.rolpassword IS NOT NULL THEN\n        '<set>'\n    ELSE\n        NULL\n    END AS password,\n    r.rolinherit AS inherit,\n    r.rolcanlogin AS login,\n    r.rolsuper AS superuser,\n    r.rolreplication AS replication,\n    CASE WHEN r.rolconnlimit <> - 1 THEN\n        r.rolconnlimit\n    ELSE\n        NULL\n    END AS connection_limit,\n    r.rolvaliduntil AS validity,\n    CASE WHEN COUNT(gi) <> 0 THEN\n        ARRAY_AGG(gi.rolname)\n    ELSE\n        ARRAY[]::text[]\n    END AS in_roles\nFROM\n    pg_authid r\n    LEFT OUTER JOIN pg_auth_members g ON g.member = r.oid\n    LEFT OUTER JOIN pg_authid gi ON g.roleid = gi.oid\nWHERE\n    r.rolname = %(username)s\nGROUP BY\n    r.rolname,\n    r.rolpassword,\n    r.rolinherit,\n    r.rolcanlogin,\n    r.rolsuper,\n    r.rolreplication,\n    r.rolconnlimit,\n    r.rolvaliduntil;",
  "role_list_names": "SELECT rolname from pg_roles ORDER BY rolname;",
  "role_revoke": "REVOKE {rolname} FROM {rolspec};"
}
