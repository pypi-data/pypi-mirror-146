Metadata-Version: 2.1
Name: pyfmtools
Version: 0.33
Summary: For handling and fitting fuzzy measures
Home-page: UNKNOWN
Author: Norbert Henseler
Author-email: norbert.henseler@deakin.edu.au
License: UNKNOWN
Platform: UNKNOWN
Description-Content-Type: text/markdown
License-File: LICENSE
Requires-Dist: cffi (>=1.0.0)

# Pyfmtools
This package handles and fits fuzzy measures Functions are:<br>
    double py_min_subset(double* x, int n, int_64 S);<br><br>
    double py_max_subset(double* x, int n, int_64 S);<br>
    void py_ConvertCard2Bit(double* dest, double* src,  struct fm_env* env);<br>
    double py_min_subsetC(double* x, int n, int_64 S, struct fm_env* env);<br>
    double py_max_subsetNegC(double* x, int n, int_64 S, struct fm_env* env);<br>
    int py_SizeArraykinteractive(int n, int k, struct fm_env* env);<br>
    int py_IsSubsetC(int i, int j, struct fm_env* env);<br> 
    int py_IsElementC(int i, int j, struct fm_env* env);<br> 
    void py_ExpandKinteractive2Bit(double* dest, double* src, struct fm_env* env, int kint, int arraysize);<br>
	void py_ExpandKinteractive2Bit_m(double* dest, double* src, struct fm_env* env, int kint, int arraysize, double* VVC);<br>
    void py_fm_init(int n, struct  fm_env* env);<br>
    void py_fm_free(struct  fm_env* env);<br>
    void py_Shapley(double* v, double* x, struct fm_env* env);<br>
    void py_Banzhaf(double* v, double* B, struct fm_env* env);<br>
    void py_ShapleyMob(double* Mob, double* x, struct fm_env* env);<br>
    void py_BanzhafMob(double* Mob, double* B, struct fm_env* env);<br>
    double py_Choquet(double* x, double* v, struct fm_env* env);<br>
    double py_ChoquetKinter(double* x, double* v, int kint, struct fm_env* env);<br>
    double py_ChoquetMob(double* x, double* Mob, struct fm_env* env);<br>
    void py_ConstructLambdaMeasure(double* singletons, double* lambda, double* v, struct fm_env* env);<br>
    void py_ConstructLambdaMeasureMob(double* singletons, double* lambda, double* Mob, struct fm_env* env);<br>
    void py_dualm(double* v, double* w, struct fm_env* env);<br>
    void py_dualmMob(double* v, double* w, struct fm_env* env);<br>
    double py_Entropy(double* v, struct fm_env* env);<br>
    void py_FuzzyMeasureFit(int datanum, int additive, struct fm_env* env, double* v, double* dataset);<br>
    void py_FuzzyMeasureFitMob(int datanum, int additive, struct fm_env* env, double* v, double* dataset);<br>
    void py_FuzzyMeasureFitKtolerant(int datanum, int additive, struct fm_env* env, double* v, double* dataset);<br>
    void py_FuzzyMeasureFitLPKmaxitive(int datanum, int additive, struct fm_env* env, double* v, double* dataset);<br>
    void py_FuzzyMeasureFitLPKinteractive(int datanum, int additive, struct fm_env* env, double* v, double* dataset, double* K);<br>
    void py_FuzzyMeasureFitLPKinteractiveMaxChains(int datanum, int additive, struct fm_env* env, double* v, double* dataset, double* K);<br>
    void py_FuzzyMeasureFitLPKinteractiveAutoK(int datanum, int additive, struct fm_env* env, double* v, double* dataset, double* K, int* maxiters);<br>
    void py_FuzzyMeasureFitLPKinteractiveMarginal(int datanum, int additive, struct fm_env* env, double* v, double* dataset, double* K, int submod);<br>
    void py_FuzzyMeasureFitLPKinteractiveMarginalMaxChain(int datanum, int additive, struct fm_env* env, double* v, double* dataset, double* K, int* maxiters, int submod);<br>
    void py_FuzzyMeasureFitLP(int datanum, int additive, struct fm_env* env, double* v, double* dataset, int * options, double* indexlow, double* indexhihg, int* option1, double* orness);<br>
    void py_FuzzyMeasureFitLPMob(int datanum, int additive, struct fm_env* env, double* v, double* dataset, int * options, double* indexlow, double* indexhihg, int* option1, double* orness);<br>
    void py_fittingOWA(int datanum, struct fm_env* env, double* v, double* dataset);<br>
    void py_fittingWAM(int datanum, struct fm_env* env, double* v, double* dataset);<br>
    void py_Interaction(double* Mob, double* v, struct fm_env* env);<br>
    void py_InteractionB(double* Mob, double* v, struct fm_env* env);<br>
    void py_InteractionMob(double* Mob, double* v, struct fm_env* env);<br>
    void py_InteractionBMob(double* Mob, double* v, struct fm_env* env);<br>
    void py_BipartitionShapleyIndex(double* v, double* w, struct fm_env* env);<br>
    void py_BipartitionBanzhafIndex(double* v, double* w, struct fm_env* env);<br>
    void py_BNonadditivityIndexMob(double* Mob, double* w, struct fm_env* env);<br>
    void py_NonadditivityIndex(double* v, double* w, struct fm_env* env);<br>
	void py_NonmodularityIndex(double* v, double* w, struct fm_env* env);<br>
	void py_NonmodularityIndexMob(double* Mob, double* w, struct fm_env* env);<br>	
	void py_NonmodularityIndexKinteractive(double* v, double* w, int kint,  struct fm_env* env);<br>
    void py_NonmodularityIndexMobkadditive(double* Mob, double* w, int k,  struct fm_env* env);<br>
   	void py_ShowCoalitions(int* coalition, struct fm_env* env);<br>
	void py_ShowCoalitionsCard(int* coalition, struct fm_env* env);<br>
    int py_IsMeasureAdditive(double* v, struct fm_env* env);<br>
    int py_IsMeasureBalanced(double* v, struct fm_env* env);<br>
    int py_IsMeasureSelfdual(double* v, struct fm_env* env);<br>
    int py_IsMeasureSubadditive(double* v, struct fm_env* env);<br>
    int py_IsMeasureSubmodular(double* v, struct fm_env* env);<br>
    int py_IsMeasureSuperadditive(double* v, struct fm_env* env);<br>
    int py_IsMeasureSupermodular(double* v, struct fm_env* env);<br>
    int py_IsMeasureSymmetric(double* v, struct fm_env* env);<br>
    int py_IsMeasureKMaxitive(double* v, struct fm_env* env);<br>
	int py_IsMeasureAdditiveMob(double* Mob, struct fm_env* env);<br> 
	int py_IsMeasureBalancedMob(double* Mob, struct fm_env* env);<br> 
	int py_IsMeasureSelfdualMob(double* Mob, struct fm_env* env);<br> 
	int py_IsMeasureSubadditiveMob(double* Mob, struct fm_env* env);<br>
	int py_IsMeasureSubmodularMob(double* Mob, struct fm_env* env);<br> 
	int py_IsMeasureSuperadditiveMob(double* Mob, struct fm_env* env);<br>
	int py_IsMeasureSupermodularMob(double* Mob, struct fm_env* env);<br> 
	int py_IsMeasureSymmetricMob(double* Mob, struct fm_env* env);<br>
	int py_IsMeasureKMaxitiveMob(double* Mob, struct fm_env* env);<br>
    void py_Mobius(double* v, double* MobVal, struct fm_env* env);<br>
    double py_Orness(double* Mob, struct fm_env* env);<br>
    double py_OWA(double* x, double* v, struct fm_env* env);<br>
    double py_Sugeno(double* x, double* v, struct fm_env* env);<br>
    double py_WAM(double* x, double* v, struct fm_env* env);<br>
    void py_Zeta(double* Mob, double* v, struct fm_env* env);<br>
	void py_dualMobKadd(int m, int length, int k, double* src, double* dest, struct fm_env* env);<br>
	void py_Shapley2addMob(double* v, double* x, int n);<br>
	void py_Banzhaf2addMob(double* v, double* x, int n);<br>
    double py_Choquet2addMob(double*x, double* Mob, int n);<br>
	int py_fm_arraysize(int n, int kint, struct fm_env* env);<br>
	int py_generate_fm_tsort(int num, int n, int kint, int markov, int option, double K, double * vv, struct fm_env* env);<br>
	int py_generate_fmconvex_tsort(int num, int n, int kint, int markov, int option, double K, double * vv, struct fm_env* env);<br>
	int py_generate_fm_minplus(int num, int n, int kint, int markov, int option, double K, double * vv, struct fm_env* env);<br>
	int py_generate_fm_2additive_convex(int num, int n,  double * vv);<br>
	int py_generate_fm_2additive_concave(int num, int n, double * vv);<br>
    int py_generate_fm_2additive_convex_withsomeindependent(int num, int n, double * vv);<br>
    void py_export_maximal_chains(int n, double* v, double* mc, struct fm_env* env);<br>
    void py_prepare_fm_sparse(int n, int tupsize, int* tuples, struct fm_env_sparse* env);<br>
    int py_tuple_cardinality_sparse(int i, struct fm_env_sparse* env);<br>
    int py_get_num_tuples(struct fm_env_sparse* env);<br>
	int py_get_sizearray_tuples(struct fm_env_sparse* env);<br>
    int py_is_inset_sparse(int A, int card, int i, struct fm_env_sparse* env);<br>
    int py_is_subset_sparse(int A, int cardA, int B, int cardB, struct fm_env_sparse* env);<br>
    double py_min_subset_sparse(double* x, int n, int S, int cardS, struct fm_env_sparse* env);<br>
	double py_max_subset_sparse(double* x, int n, int S, int cardS, struct fm_env_sparse* env);<br>
    double py_ChoquetMob_sparse(double* x, int n, struct fm_env_sparse* env);<br>
    void py_ShapleyMob_sparse(double* v, int n, struct fm_env_sparse* env);<br>
	void py_BanzhafMob_sparse(double* v, int n, struct fm_env_sparse* env);<br>
    void py_populate_fm_2add_sparse(double* singletons, int numpairs, double* pairs, int* indicesp1, int* indicesp2, struct fm_env_sparse* env);<br>
    void py_add_pair_sparse(int i, int j, double v, struct fm_env_sparse* env);<br>
    void py_add_tuple_sparse(int tupsize, int* tuple, double v, struct fm_env_sparse* env);<br>
    void py_populate_fm_2add_sparse_from2add(int n, double * v, struct fm_env_sparse* env);<br>
    void py_expand_2add_full(double* v, struct fm_env_sparse* env);<br>
    void py_expand_sparse_full(double* v, struct fm_env_sparse* env);<br>
	void py_sparse_get_singletons(int n, double* v, struct fm_env_sparse* env);<br>
	int py_sparse_get_pairs(int* pairs, double* v, struct fm_env_sparse* env);<br>
	int py_sparse_get_tuples(int* tuples, double* v, struct fm_env_sparse* env);<br>
    int   py_generate_fm_2additive_convex_sparse(int n, struct fm_env_sparse* env);<br>
    int   py_generate_fm_kadditive_convex_sparse(int n, int k, int nonzero, struct fm_env_sparse* env);<br>
    void py_Nonmodularityindex_sparse(double* w, int n, struct fm_env_sparse* env);<br>

## Documentation
[User Manual](http://gbfiles.epizy.com/pyfmtools.pdf)

## Installation
To install type:
```python
$ pip install pyfmtools
```
## Usage of the library
```python
from _pyfmtools import flib, lib
```
Follow these steps in your Python code to use the library:<br>
- Initialize resources<br>
- Use library function(s)<br>
- Free resources<br>
### Example how to initialize resources
r=3<br>
n=3<br>
env=ffi.new( "struct fm_env *")<br>
fm.py_fm_init( n, env)<br>

### Example how to free resources
fm.py_fm_free( env)<br>

## Usage of library functions
To implement a function follow these steps:
1. Check size of input arrays. Example:
2. Check types of input arrays. Example:
3. Use CFFI type conversion for each input array or pointer. Example:
4. Call C or C++ function. Example:
### Parameters
#### Input parameters:
See function list
#### Output parameters:
See function list 

## Test
To unit test type:
```python
$ test/test.py
```

